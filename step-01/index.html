<!DOCTYPE html>
<!--[if IE 7]><html class="ie ie7" lang="ja"><![endif]-->
<!--[if IE 8]><html class="ie ie8" lang="ja"><![endif]-->
<!--[if !(IE 7) & !(IE 8)]><!--><html lang="ja"><!--<![endif]-->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>前置記法を採用したプログラミング言語 | MaryCore</title>
<meta property="og:type" content="article"><meta property="og:site_name" content="MaryCore 言語知能総合研究所"><meta property="og:url" content="http://marycore.jp/step-01/"><meta property="og:title" content="前置記法を採用したプログラミング言語"><meta property="og:description" content=";; ;; 概要 ;; ;; 前置記法／ポーランド記法を採用したプログラミング言語。 + 1 2 ; ポーランド記法 1 2 +・・・"><!--[if lt IE 9]><script src="http://marycore.jp/wp/wp-content/themes/twentytwelve/js/html5.js" type="text/javascript"></script><![endif]-->
<link rel='stylesheet' id='twentytwelve-style-css'  href='http://marycore.jp/wp/wp-content/themes/marycore/style.css?ver=4.9.9' type='text/css' media='all' />
<!--[if lt IE 9]>
<link rel='stylesheet' id='twentytwelve-ie-css'  href='http://marycore.jp/wp/wp-content/themes/twentytwelve/css/ie.css?ver=20121010' type='text/css' media='all' />
<![endif]-->
<link rel="canonical" href="http://marycore.jp/step-01/" />
</head>
<body class="page-template-default page page-id-1928"><div id="page" class="hfeed site"><header id="masthead" class="site-header" role="banner"><hgroup><h1 class="site-title"><a href="http://marycore.jp/" title="ヽ( ・ω・)ノ Don&#039;t feel. THINK! ~ Presented by MaryCore ~" rel="home">MaryCore</a></h1></hgroup><nav id="site-navigation" class="main-navigation" role="navigation"><button class="menu-toggle">メニュー</button><a class="assistive-text" href="#content" title="コンテンツへ移動">コンテンツへ移動</a><div class="menu-%e3%83%a1%e3%83%8b%e3%83%a5%e3%83%bc-1-container"><ul id="menu-%e3%83%a1%e3%83%8b%e3%83%a5%e3%83%bc-1" class="nav-menu"><li id="menu-item-2763" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2763"><a title="McTap／キーボード拡張アプリ" href="http://marycore.jp/mctap/">新作ソフトウェア<sup class="badge-info-invert">New!</sup></a></li>
<li id="menu-item-515" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-515"><a title="制作したアプリ／Our Applications" href="http://marycore.jp/apps/">アプリ</a></li>
<li id="menu-item-86" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-86"><a title="サイトについて／About this site" href="http://marycore.jp/about/">サイトについて</a></li>
<li id="menu-item-87" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-87"><a title="Contact／お問い合わせ" href="http://marycore.jp/contact/">お問い合わせ</a></li>
<li id="menu-item-242" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-242"><a title="Sitemap／サイトマップ" href="http://marycore.jp/sitemap/">サイトマップ</a></li>
<li id="menu-item-3180" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-3180"><a target="_blank" href="https://cse.google.com:443/cse/publicurl?cx=009489372983289696163:xjk7xgk_hm4">検索</a></li>
</ul></div></nav></header><div id="main" class="wrapper"><div id="breadcrumb" class="breadcrumb"><div itemscope itemtype="http://data-vocabulary.org/Breadcrumb"><a href="http://marycore.jp/" itemprop="url"><span itemprop="title">Home</span></a> › </div><div><span>前置記法を採用したプログラミング言語</span></div></div>
	<div id="primary" class="site-content">
		<div id="content" role="main">

							
	<article id="post-1928" class="post-1928 page type-page status-publish hentry">
		<header class="entry-header">
												<h1 class="entry-title">前置記法を採用したプログラミング言語</h1>
		</header>

		<div class="entry-content">
			<pre><code class="code code-4 lang-lisp"><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 概要
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; 前置記法／ポーランド記法を採用したプログラミング言語。
</span>
+ 1 2  <span class="code-attr-comment-block">; ポーランド記法
</span>1 2 +  <span class="code-attr-comment-block">; 逆ポーランド記法
</span>1 + 2  <span class="code-attr-comment-block">; 中置記法
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; サンプル（プログラミング言語）
</span><span class="code-attr-comment-block">;;
</span>
:str <span class="code-attr-string">"hello"</span>          <span class="code-attr-comment-block">; var str = "hello"
</span><span class="code-attr-label">ary</span>: [<span class="code-attr-string">"world"</span> <span class="code-attr-string">"end"</span>]  <span class="code-attr-comment-block">; var ary = ["world", "end"]
</span>
<span class="code-attr-keyword">print</span> str ary.0        <span class="code-attr-comment-block">; print("hello", "world")
</span>
:v + 1 2
<span class="code-attr-keyword">print</span> v    <span class="code-attr-comment-block">; 3
</span>
- + 1 2 2   <span class="code-attr-comment-block">;  1
</span>- (+ 1 2 2) <span class="code-attr-comment-block">; -5
</span>
<span class="code-attr-keyword">if</span> = <span class="code-attr-string">"hello"</span> str
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"yes"</span>
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"no"</span>

<span class="code-attr-keyword">print</span> (<span class="code-attr-keyword">if</span> = <span class="code-attr-string">"hello"</span> str <span class="code-attr-string">"yes"</span> <span class="code-attr-string">"no"</span>)

[<span class="code-attr-keyword">print</span> [<span class="code-attr-keyword">if</span> <span class="code-attr-label">cond</span>:[= <span class="code-attr-string">"hello"</span> str]
           <span class="code-attr-label">then</span>:<span class="code-attr-string">"yes"</span>
           <span class="code-attr-keyword">else</span>:<span class="code-attr-string">"no"</span>]]

<span class="code-attr-keyword">switch</span> <span class="code-attr-object">Align</span>.<span class="code-attr-object">Left</span>
  :<span class="code-attr-object">Left</span>   <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"Left"</span>
  :<span class="code-attr-object">Right</span>  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"Right"</span>
  :<span class="code-attr-object">Center</span> <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"Center"</span>

[1 2 3].head <span class="code-attr-comment-block">; 1
</span>[1 2 3].rest <span class="code-attr-comment-block">; [2 3]
</span>
sort [3 2 1] {|a b| &lt; a b}  <span class="code-attr-comment-block">; [1 2 3]
</span>[3 2 1].sort {&lt; $0 $1}      <span class="code-attr-comment-block">; [1 2 3]
</span>[3 2 1].sort (&lt;)            <span class="code-attr-comment-block">; [1 2 3]
</span><span class="code-attr-method">sort</span>{&lt;} [3 2 1]             <span class="code-attr-comment-block">; [1 2 3]
</span>filter&lt;&amp; 1&gt; [3 2 1]         <span class="code-attr-comment-block">; [1 3]
</span>
<span class="code-attr-keyword">func</span> counter ()
  :c 0
  ~~ = c (+ c 1)

= f counter
f  <span class="code-attr-comment-block">; 1
</span>f  <span class="code-attr-comment-block">; 2
</span>
<span class="code-attr-keyword">func</span> fact n
  <span class="code-attr-keyword">if</span> = n 0
     1
     * n
       <span class="code-attr-type">this</span> - n 1

fact 3  <span class="code-attr-comment-block">; 6
</span>fact 4  <span class="code-attr-comment-block">; 24
</span>
<span class="code-attr-keyword">func</span> sum list
  + list.car
    <span class="code-attr-keyword">if</span> list.cdr
       sum list.cdr
       0

sum [1 2] <span class="code-attr-comment-block">; 3
</span>
times&lt;3 i&gt; {<span class="code-attr-keyword">print</span> i} <span class="code-attr-comment-block">; "012"
</span>times&lt;3 i&gt; <span class="code-attr-keyword">print</span> i   <span class="code-attr-comment-block">; "012"
</span>times 3 <span class="code-attr-keyword">print</span> _      <span class="code-attr-comment-block">; "012"
</span>times 3 <span class="code-attr-keyword">print</span>        <span class="code-attr-comment-block">; "012"
</span>
len <span class="code-attr-string">"str"</span>     <span class="code-attr-comment-block">; 3
</span><span class="code-attr-string">"str"</span>.len     <span class="code-attr-comment-block">; 3
</span>[<span class="code-attr-string">"str"</span>].0 len <span class="code-attr-comment-block">; 3
</span>1.+ 2      <span class="code-attr-comment-block">; 3  ;; 1.+(2)
</span>1 + 2      <span class="code-attr-comment-block">; 3  ;; 1.+ 2
</span>+(1 2)     <span class="code-attr-comment-block">; 3
</span>
join <span class="code-attr-string">"-"</span>, <span class="code-attr-method">map</span>{to_s}\reverse\sort [1 3 2] <span class="code-attr-comment-block">; "3-2-1"
</span><span class="code-attr-string">"-"</span>.join <span class="code-attr-method">map</span>{to_s} \ sort&lt;a b&gt;{- a b} [1 3 2] <span class="code-attr-comment-block">; "3-2-1"
</span>
assert (= yes <span class="code-attr-type">true</span> 1)

~~ sum (a b) + a b
<span class="code-attr-keyword">print</span>-sum 1 2 <span class="code-attr-comment-block">; "3"
</span>
<span class="code-attr-label">main</span>: {
  <span class="code-attr-label">object</span>:
    :v 99
    :f ~~ <span class="code-attr-keyword">print</span> (+ $0.k <span class="code-attr-string">" "</span> v)
  object.f {<span class="code-attr-label">k</span>: <span class="code-attr-string">"Shop"</span>}
}
<span class="code-attr-method">main</span>() <span class="code-attr-comment-block">; Shop 99
</span>main.object <span class="code-attr-comment-block">; 99
</span><span class="code-attr-keyword">print</span> main..object <span class="code-attr-comment-block">; Shop 99\n99
</span></code></pre>
<div class="dbl-rc"><div class="content_toc content_toc_01" style="margin-bottom:18px;margin-bottom:1.2857142857rem"><style type="text/css">.slot_content_toc_01{width:300px;height:250px}@media (min-width:375px){.slot_content_toc_01{width:336px;height:280px}}@media (min-width:950px){.slot_content_toc_01{width:300px;height:250px}}@media (min-width:1075px){.slot_content_toc_01{width:336px;height:280px}}</style><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle slot_content_toc_01" style="display:block" data-ad-client="ca-pub-5613714714878183" data-ad-slot="2558316956" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div><div class="content_toc content_toc_02" style="margin-bottom:18px;margin-bottom:1.2857142857rem"><style type="text/css">.slot_content_toc_02{width:300px;height:250px}@media (min-width:375px){.slot_content_toc_02{width:336px;height:280px}}@media (min-width:950px){.slot_content_toc_02{width:300px;height:250px}}@media (min-width:1075px){.slot_content_toc_02{width:336px;height:280px}}</style><ins class="adsbygoogle slot_content_toc_02" style="display:block" data-ad-client="ca-pub-5613714714878183" data-ad-slot="3352115982" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div></div><div style="clear:both"></div><style>.dbl-rc>div{width:50%;float:left}@media (max-width:950px){.dbl-rc>div:last-child{display:none}.dbl-rc>div{witdh:100%}}</style>
<pre><code class="code code-4 lang-lisp"><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 設計方針
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; インタプリタまたはハイブリッド
</span><span class="code-attr-comment-block">;; 型システムなし。eval相当機能あり
</span><span class="code-attr-comment-block">;; for文if文等の基本機能はライブラリ関数として実装
</span><span class="code-attr-comment-block">;; コア言語側である程度の組み込み型を用意する
</span><span class="code-attr-comment-block">;;  - Number型、String型、List型、Map型、Key型、Function型
</span><span class="code-attr-comment-block">;;  - 組み込み型のメンバ関数はライブラリ側で実装可能とする
</span><span class="code-attr-comment-block">;; 組み込みの糖衣構文は極力宣言しない
</span><span class="code-attr-comment-block">;;  - 前置記法を活かした構文をベースとする
</span><span class="code-attr-comment-block">;;  - 予約済みのキーワードは極力定義しない
</span><span class="code-attr-comment-block">;; DSLの実現を可能とする汎用的な言語仕様
</span><span class="code-attr-comment-block">;;  - 多様性を受け入れる寛容プログラミング言語
</span><span class="code-attr-comment-block">;;  - 設定ファイルの構文やマックアップ言語への応用を可能とする
</span><span class="code-attr-comment-block">;;  - ライブラリ次第でまったく異なる構文の利用が可能となる（方言の実現）
</span><span class="code-attr-comment-block">;;    - 中置記法、Lisp風記法、Smalltalk風のオブジェクト指向機構、等々
</span><span class="code-attr-comment-block">;;    - 未定義動作や処理系依存の動作を方言側で制御可能とする（実引数の評価順序等）
</span><span class="code-attr-comment-block">;;  - リアルタイム・インタプリタインタプリタ（インタプリタジェネレータ）
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 仕様
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ２０１６年１２月２４日　公開
</span><span class="code-attr-comment-block">;; ２０１７年０１月２８日　更新
</span><span class="code-attr-comment-block">;; ２０１７年０４月２８日　更新
</span><span class="code-attr-comment-block">;; ２０１７年０９月２８日　更新
</span><span class="code-attr-comment-block">;; ２０１８年０２月２８日　更新
</span><span class="code-attr-comment-block">;; ２０１８年１０月２８日　更新
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 基本構文
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 代入・比較
</span><span class="code-attr-comment-block">;;
</span>= i 3    <span class="code-attr-comment-block">; var i = 3
</span>== i 3   <span class="code-attr-comment-block">; i == 3
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 四則演算
</span><span class="code-attr-comment-block">;;
</span>+ 1 2    <span class="code-attr-comment-block">; 1 + 2
</span>- 1 2    <span class="code-attr-comment-block">; 1 - 2
</span>
+ 1 2 3       <span class="code-attr-comment-block">; 1 + 2 + 3
</span>+ 1, 2, 3     <span class="code-attr-comment-block">; 1 + 2 + 3
</span>(+ 1 2 3)     <span class="code-attr-comment-block">; 1 + 2 + 3
</span>+(1 2 3)      <span class="code-attr-comment-block">; 1 + 2 + 3       ;; 要検討（糖衣構文）
</span>+ (1 2 3) 4   <span class="code-attr-comment-block">; [1, 2, 3] + 4   ;; 要検証
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 二項演算優先の原則（保留・廃止予定）
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">; + 1 2 3       ; 1 + 2; 3;
</span><span class="code-attr-comment-block">; + + 1 2 3     ; (1 + 2) + 3
</span><span class="code-attr-comment-block">; * + 1 2 - 6 3 ; (1 + 2) * (6 - 3)
</span><span class="code-attr-comment-block">; 1 + 2         ; 1 (+ 2 nil)
</span><span class="code-attr-comment-block">; if == nil v return 0 ; if (nil == v) return 0
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; リテラル
</span><span class="code-attr-comment-block">;;
</span>99         <span class="code-attr-comment-block">; Number
</span><span class="code-attr-string">"abc"</span>      <span class="code-attr-comment-block">; String
</span>[1 2 3]    <span class="code-attr-comment-block">; List
</span>(1 2 3)    <span class="code-attr-comment-block">; List ;; 要検討
</span>[:key 99]  <span class="code-attr-comment-block">; Map
</span>[<span class="code-attr-label">key</span>: 99]  <span class="code-attr-comment-block">; Map  ;; 要検討（糖衣構文）
</span>{:key 99}  <span class="code-attr-comment-block">; Map  ;; 要検討
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 配列／リスト
</span><span class="code-attr-comment-block">;;
</span>= ary [1 2 3]
ary 0   <span class="code-attr-comment-block">; 1
</span>ary[1]  <span class="code-attr-comment-block">; 2 ;; 糖衣構文
</span>ary.2   <span class="code-attr-comment-block">; 3 ;; メンバアクセス
</span><span class="code-attr-method">ary</span>(2)  <span class="code-attr-comment-block">; 3 ;; 転送
</span>*ary      <span class="code-attr-comment-block">; 1
</span>+ary      <span class="code-attr-comment-block">; [2 3]
</span>ary.car   <span class="code-attr-comment-block">; 1
</span>ary.cdr   <span class="code-attr-comment-block">; [2 3]
</span>ary.first <span class="code-attr-comment-block">; 1
</span>ary.head  <span class="code-attr-comment-block">; 1
</span>ary.last  <span class="code-attr-comment-block">; 3
</span>ary.tail  <span class="code-attr-comment-block">; 3
</span>ary.rest  <span class="code-attr-comment-block">; [2 3]
</span>ary.begin <span class="code-attr-comment-block">; &amp;[1 2 3][0]
</span>ary.end   <span class="code-attr-comment-block">; &amp;[1 2 3][[1 2 3].size]
</span>ary.<span class="code-attr-method">from</span>(1) <span class="code-attr-comment-block">; [2 3]
</span><span class="code-attr-method">ary</span>(<span class="code-attr-label">to</span>: 2)  <span class="code-attr-comment-block">; [1 2]
</span><span class="code-attr-method">to</span>(ary, 2)  <span class="code-attr-comment-block">; [1 2]
</span>ary[<span class="code-attr-label">1</span>:]     <span class="code-attr-comment-block">; [2 3]
</span>ary[:2]     <span class="code-attr-comment-block">; [1 2]
</span>ary[<span class="code-attr-label">1</span>:2]    <span class="code-attr-comment-block">; [2]
</span>ary-0       <span class="code-attr-comment-block">; 1
</span><span class="code-attr-label">ary-1</span>:      <span class="code-attr-comment-block">; [2 3]
</span><span class="code-attr-label">ary</span>:2       <span class="code-attr-comment-block">; [1 2]
</span><span class="code-attr-label">ary-1</span>:2     <span class="code-attr-comment-block">; [2]
</span>
ary.take 2   <span class="code-attr-comment-block">; [1 2]
</span>ary.before 2 <span class="code-attr-comment-block">; [1 2]
</span>ary.prefix 2 <span class="code-attr-comment-block">; [1 2]
</span>ary.drop 2   <span class="code-attr-comment-block">; [3]
</span>ary.after 2  <span class="code-attr-comment-block">; [3]
</span>ary.suffix 2 <span class="code-attr-comment-block">; [3]
</span>ary.chop 2     <span class="code-attr-comment-block">; [1]
</span>ary.dropLast 2 <span class="code-attr-comment-block">; [1]
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 辞書／連想配列
</span><span class="code-attr-comment-block">;;
</span>= dic [:key 99 :may 5]
dic <span class="code-attr-string">"key"</span>   <span class="code-attr-comment-block">; 99
</span>dic[<span class="code-attr-string">"key"</span>]  <span class="code-attr-comment-block">; 99 ;; 糖衣構文
</span>dic.key     <span class="code-attr-comment-block">; 99
</span><span class="code-attr-method">dic</span>(:key)   <span class="code-attr-comment-block">; 99
</span>dic[:key]   <span class="code-attr-comment-block">; 99
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 関数
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 関数定義式の採用は保留
</span><span class="code-attr-comment-block">;;  - 無名関数を変数へ代入することで代用
</span><span class="code-attr-comment-block">;;
</span>= add fn (a b) + a b  <span class="code-attr-comment-block">; function add(a, b) { a + b }
</span>add 1 2   <span class="code-attr-comment-block">; 3
</span>add 1, 2  <span class="code-attr-comment-block">; 3
</span><span class="code-attr-method">add</span>(1 2)  <span class="code-attr-comment-block">; 3
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 無名関数
</span><span class="code-attr-comment-block">;;
</span>= sub ~ (a b) - a b  <span class="code-attr-comment-block">;; 要検討（糖衣構文または基本構文とする）
</span>= mul ~~ * $0 $1     <span class="code-attr-comment-block">;; 案２-１
</span>= div ~~ / _0 _1     <span class="code-attr-comment-block">;; 案２-２
</span>= add ~~ + _  _      <span class="code-attr-comment-block">;; 案２-３
</span>= rem ^(a b) % a b   <span class="code-attr-comment-block">;; 案３
</span>= add {(a b) + a b}  <span class="code-attr-comment-block">;; 案４-１
</span>= add {+ _0 _1}      <span class="code-attr-comment-block">;; 案４-２（仮引数省略時専用）
</span>= add {[a b] + a b}  <span class="code-attr-comment-block">;; 案４-３（案４-２との混在が可能）-- 参考：[#引数リスト]
</span>= add [a b]{+ a b}   <span class="code-attr-comment-block">;; 案４-４（案４-２との混在が可能）-- 参考：[#引数リスト] [#前置引数リスト] #1%
</span>= add [a b] {+ a b}  <span class="code-attr-comment-block">;; 案４-５（不可: 配列型引数と解釈 -- `sort [2 1] {&lt;}`）
</span>= add {a b| + a b}   <span class="code-attr-comment-block">;; 案５ [#ラムダ宣言式の追加]
</span>
sort [2 1] {&lt;} <span class="code-attr-comment-block">;; sort([2 1] (&lt;))
</span>[2 1].sort |a b| &lt; a b
[2 1].sort {a b| &lt; a b}
[2 1].<span class="code-attr-method">sort</span>(|a b| &lt; a b)
[2 1].<span class="code-attr-method">sort</span>([a b]{&lt; a b}) <span class="code-attr-comment-block">;; 煩雑
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; オブジェクト指向
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; メソッド
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-string">"s"</span>.len <span class="code-attr-type">nil</span>       <span class="code-attr-comment-block">; "s".len()
</span><span class="code-attr-string">"s"</span>.<span class="code-attr-method">len</span>()         <span class="code-attr-comment-block">; 糖衣構文
</span><span class="code-attr-string">"s"</span> len           <span class="code-attr-comment-block">; "s"(:len)
</span>len <span class="code-attr-string">"s"</span>           <span class="code-attr-comment-block">; 転送 --&gt; "s".len()
</span><span class="code-attr-string">"R"</span>.sub <span class="code-attr-string">"R"</span>, <span class="code-attr-string">"r"</span>  <span class="code-attr-comment-block">; "R".sub("R", "r")
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; クラス
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-keyword">class</span> <span class="code-attr-object">Number</span>
  fn init   (v) = <span class="code-attr-type">self</span>.intValue v
  fn is, eq (v) == v <span class="code-attr-type">self</span>.intValue
  fn pow    (v) <span class="code-attr-object">Math</span>.<span class="code-attr-method">pow</span>(<span class="code-attr-type">self</span>.intValue v)
  fn (+)    (v) + <span class="code-attr-type">self</span>.intValue v
  fn get    ( ) <span class="code-attr-keyword">return</span> <span class="code-attr-type">self</span>.intValue
  <span class="code-attr-comment-block">;; 案２
</span>  = is  fn (v) == <span class="code-attr-type">self</span> v
  = pow fn (v) <span class="code-attr-object">Math</span>.pow <span class="code-attr-type">self</span> v
  = pow {[v]
    <span class="code-attr-object">Math</span>.pow <span class="code-attr-type">self</span> v
  }
  <span class="code-attr-comment-block">;; fn VS func
</span>  <span class="code-attr-comment-block">;; 無名関数との区別のためにfuncの採用を検討
</span>  <span class="code-attr-comment-block">;; func name(a b) + a b  ; メソッド宣言式
</span>  <span class="code-attr-comment-block">;; fn (a b) + a b        ; ラムダ式
</span>  
  <span class="code-attr-comment-block">;; Objective-C風
</span>  - <span class="code-attr-method">instanceMethod</span>() + 1 2
  + <span class="code-attr-method">classMethod</span>()    + 1 2
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; インスタンス化
</span><span class="code-attr-comment-block">;;
</span>= v (<span class="code-attr-object">Number</span> 99)

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; メソッド呼び出し
</span><span class="code-attr-comment-block">;;
</span>get v     <span class="code-attr-comment-block">; 9
</span>v get     <span class="code-attr-comment-block">; 9
</span>v.<span class="code-attr-method">get</span>()   <span class="code-attr-comment-block">; 9
</span>v.get     <span class="code-attr-comment-block">; func Number::get
</span>v.get <span class="code-attr-type">nil</span> <span class="code-attr-comment-block">; 9
</span>(9.get)   <span class="code-attr-comment-block">; 9
</span>v.eq 2    <span class="code-attr-comment-block">; v.eq(2)
</span>10.pow 3  <span class="code-attr-comment-block">; 1000
</span>v is 4    <span class="code-attr-comment-block">; v.is(4)
</span>eq v 2    <span class="code-attr-comment-block">; v.eq(2) ;; [#代理関数呼び出し]
</span>
<span class="code-attr-comment-block">;; #domain-specific
</span><span class="code-attr-method">2</span>(3) <span class="code-attr-comment-block">; 6
</span>= x 4
<span class="code-attr-method">2</span>(x) <span class="code-attr-comment-block">; 8
</span>= <span class="code-attr-method">f</span>(x) <span class="code-attr-method">2</span>(x)
<span class="code-attr-method">f</span>(5) <span class="code-attr-comment-block">; 10
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 糖衣構文
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-string">""</span>.<span class="code-attr-method">split</span>(<span class="code-attr-string">","</span>) <span class="code-attr-comment-block">; ("".split ",")
</span><span class="code-attr-string">""</span>.<span class="code-attr-method">len</span>()      <span class="code-attr-comment-block">; ("".len void)
</span><span class="code-attr-method">print</span>(<span class="code-attr-string">""</span>)     <span class="code-attr-comment-block">; (print "")
</span>+ v 2         <span class="code-attr-comment-block">; v.+(2)
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; オブジェクト
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; あらゆる値はオブジェクトで表現される
</span><span class="code-attr-comment-block">;; 各演算子の挙動は被演算子側のオブジェクト実装に依存する
</span><span class="code-attr-comment-block">;;
</span>= (+) ~~ (a b) (a.+ b)
+ 1 2       <span class="code-attr-comment-block">; 3
</span><span class="code-attr-keyword">class</span> <span class="code-attr-object">String</span>
  <span class="code-attr-keyword">func</span> `+`(s) _s.copy.append s
+ <span class="code-attr-string">"a"</span> <span class="code-attr-string">"b"</span>   <span class="code-attr-comment-block">; "ab"
</span><span class="code-attr-string">"a"</span>.+(<span class="code-attr-string">"b"</span>)  <span class="code-attr-comment-block">; "ab"
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; Anyクラス
</span><span class="code-attr-comment-block">;; 全てのオブジェクトはAnyプロトコルに準拠する
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-keyword">class</span> <span class="code-attr-object">Any</span>
  <span class="code-attr-keyword">func</span> (==) (b) __UNIMPLEMENTED__ b
  <span class="code-attr-keyword">func</span> (!=) (b) ! <span class="code-attr-type">self</span>.==(b)
<span class="code-attr-keyword">class</span> <span class="code-attr-object">Object</span> :<span class="code-attr-object">Any</span>
  <span class="code-attr-keyword">func</span> eq (b) == <span class="code-attr-type">self</span> b
<span class="code-attr-keyword">class</span> <span class="code-attr-object">String</span>
  <span class="code-attr-keyword">func</span> (!=) (b) ! (__builtin__[<span class="code-attr-string">"string.h"</span>].strcmp
                   <span class="code-attr-type">self</span>.__raw__
                      b.__raw__)

!= <span class="code-attr-string">"a"</span> <span class="code-attr-string">"b"</span> <span class="code-attr-comment-block">; true
</span>eq <span class="code-attr-string">"a"</span> <span class="code-attr-string">"b"</span> <span class="code-attr-comment-block">; &lt;&lt;&lt;error String:Any("a") eq String:Any("b")&gt;&gt;&gt;
</span>
extension <span class="code-attr-object">Number</span> :<span class="code-attr-object">Object</span>
  <span class="code-attr-keyword">func</span> `==`() (== <span class="code-attr-type">self</span>.__raw__ $0)

!= 9 8 <span class="code-attr-comment-block">; true
</span>eq 9 9 <span class="code-attr-comment-block">; true
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 中置記法
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-keyword">class</span> <span class="code-attr-object">Number</span>
  <span class="code-attr-keyword">func</span> __call__ (op ...)
    <span class="code-attr-keyword">if</span> == (+) op
      + <span class="code-attr-type">self</span> ...
      __UNIMPLEMENTED__ <span class="code-attr-type">this</span>
1 + 2     <span class="code-attr-comment-block">; (1 + 2) --&gt; 1(+, 2) --&gt; 1.+(2)
</span>+ 1 2 + 3 <span class="code-attr-comment-block">; + 1 (2.+ 3) ;; 要検討（糖衣構文に対する優先順位）
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; コア機能
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 参考：
</span><span class="code-attr-comment-block">;;   #用語の意味
</span><span class="code-attr-comment-block">;;   #予約語
</span><span class="code-attr-comment-block">;;   #備考
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ブロックの解釈
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; インデントで式の繋がりを表現する
</span><span class="code-attr-comment-block">;;  - 複文の実現が可能になる（関数の処理部やクラスのメソッド宣言部で使用）
</span><span class="code-attr-comment-block">;;  - 入れ子された式の延長用途にも使われる
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 深さ１：
</span><span class="code-attr-comment-block">;;    一つ前の階層の式に対応する要素式であることを意味する
</span><span class="code-attr-comment-block">;; 深さ２以上：
</span><span class="code-attr-comment-block">;;    前の行の最後の式に続く要素式であることを意味する
</span><span class="code-attr-comment-block">;; 特性
</span><span class="code-attr-comment-block">;;    インデントされた要素式は単一の式として解釈される
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 例（深さ１） ※ インデント幅は空白２つと仮定
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">; + 1 2
</span>+
  1
  2
<span class="code-attr-comment-block">; + 1 2
</span>+ 1
  2
<span class="code-attr-comment-block">; + 1 (2 3)
</span>+ 1
  2 3  <span class="code-attr-comment-block">;; 3は`+`関数の第三引数にならない
</span><span class="code-attr-comment-block">; (+ 1 2 3)
</span>+ 1
  2
  3
<span class="code-attr-comment-block">; + 1 (+ 2 3)
</span>+ 1
  + 2 3
<span class="code-attr-comment-block">; + (+ 1 2) 3
</span>+
  + 1 2
  3
<span class="code-attr-comment-block">; - (+ 1 2 3) 4
</span>-
  + 1 2
    3
  4
<span class="code-attr-comment-block">; = v (+ 1 2)
</span>= v
  + 2 3

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 例（深さ２以上）
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">; + 1 (+ 2 3)
</span>+ 1 + 2
    3
<span class="code-attr-comment-block">; + 1 (+ 2 3)
</span>+ 1 + 2
      3
<span class="code-attr-comment-block">; = v (+ 1 (+ 2 3) 4)
</span>= v
  + 1 + 2   <span class="code-attr-comment-block">;; 関連: [#演算子の結合規則]
</span>        3
    4
<span class="code-attr-comment-block">; = add {[a b] (+ a b)}
</span>= add fn (a b)
        + a b

<span class="code-attr-keyword">if</span> == <span class="code-attr-type">true</span> yes
  <span class="code-attr-label">then</span>:
    <span class="code-attr-keyword">print</span> <span class="code-attr-string">"true ="</span>
    <span class="code-attr-keyword">print</span> <span class="code-attr-string">"= yes"</span>
  <span class="code-attr-keyword">else</span>:
    <span class="code-attr-keyword">print</span> <span class="code-attr-string">"true !"</span>
    <span class="code-attr-keyword">print</span> <span class="code-attr-string">"= yes"</span>

<span class="code-attr-keyword">if</span>
  <span class="code-attr-label">cond</span>: == <span class="code-attr-type">true</span> yes
  <span class="code-attr-label">then</span>: <span class="code-attr-string">"yes"</span>
  <span class="code-attr-keyword">else</span>:
    <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"n"</span>
    <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"o"</span>

<span class="code-attr-comment-block">; if yes (echo "yes") (echo "no")
</span><span class="code-attr-keyword">if</span> yes
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"yes"</span>
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"no"</span>
<span class="code-attr-comment-block">; if yes (do (echo "ye") (echo "s")) (echo "no")
</span><span class="code-attr-keyword">if</span> yes <span class="code-attr-keyword">do</span>
    <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"ye"</span>
    <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"s"</span>
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"no"</span>

<span class="code-attr-comment-block">;; ブロック補完（深さ２以上） -- #TODO
</span><span class="code-attr-comment-block">; if yes (do (echo "ye") (echo "s")) (echo "no")
</span><span class="code-attr-keyword">if</span> yes
    <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"ye"</span>
    <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"s"</span>
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"no"</span>

<span class="code-attr-comment-block">;; ブロック補完（深さ１） -- 後置Keyの結合規則 #TODO
</span><span class="code-attr-comment-block">; if yes (then: (echo "ye") (echo "s"))
</span><span class="code-attr-keyword">if</span> yes <span class="code-attr-label">then</span>:
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"ye"</span>
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"s"</span>
<span class="code-attr-comment-block">; if yes (do (echo "ye") (echo "s")) -- 関連: [#ブロック内包式の結合規則#ブロック内包式の演算子結合]
</span><span class="code-attr-keyword">if</span> (yes):
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"ye"</span>
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"s"</span>

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ブロック内包式の結合規則
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #拡張機能  #重要度 50%  #影響度 100%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ブロックを内包する式の結合規則に例外を設ける
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  ブロック内包式の例外
</span><span class="code-attr-comment-block">;;    ブロックが出現するまでのオペランドの並びを要素式として解釈する
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;     #関連 [#演算子の結合規則（拡張）]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  インデントの深さに関する例外  #拡張機能
</span><span class="code-attr-comment-block">;;    インデントの深さはオペレーターの位置を考慮した形で計算される
</span><span class="code-attr-comment-block">;;    深さ１と深さ２、３を区別する
</span><span class="code-attr-comment-block">;;    わかりやすさを考慮し、インデントの深さではなくオペレータの位置関係を基準に統一する必要がある
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;     #関連 [#ブロックの解釈]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  ブロック内包式の演算子結合   #[重要度 25%] #TODO
</span><span class="code-attr-comment-block">;;    演算子がオペランドを必要とする場合
</span><span class="code-attr-comment-block">;;    内包するブロックをその演算子のオペランドと解釈する
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">; if (== "String" (typeof String)) "yes"
</span><span class="code-attr-keyword">if</span> == <span class="code-attr-string">"String"</span> typeof <span class="code-attr-object">String</span>
  <span class="code-attr-string">"yes"</span>
<span class="code-attr-comment-block">; if (== "String" typeof) (String) ("yes")
</span><span class="code-attr-keyword">if</span> == <span class="code-attr-string">"String"</span> typeof <span class="code-attr-object">String</span> <span class="code-attr-string">"yes"</span>
<span class="code-attr-comment-block">; if (== "String" (typeof String "yes"))
</span><span class="code-attr-keyword">if</span> == <span class="code-attr-string">"String"</span> typeof <span class="code-attr-object">String</span>
                      <span class="code-attr-string">"yes"</span>

<span class="code-attr-keyword">echo</span>, add 1 2 <span class="code-attr-comment-block">; echo (add 1 2) 3
</span>  3
<span class="code-attr-keyword">echo</span>, add 1 2 <span class="code-attr-comment-block">; echo (add 1 2 3)
</span>         3
<span class="code-attr-keyword">echo</span>, add 1 2 <span class="code-attr-comment-block">; echo add (1 2 3)     ;; ???: オペレーターの位置を考慮した場合
</span>           3
<span class="code-attr-keyword">echo</span>, add 1 2 <span class="code-attr-comment-block">; echo (add (1 2 3)) 4 ;; ???: 矯正インデント
</span>           3
    4
<span class="code-attr-keyword">echo</span>, add 1 2 <span class="code-attr-comment-block">; echo (add 1 2 3) 4   ;; ???
</span>         3
    4

+ * 1  <span class="code-attr-comment-block">;; (+ (* 1 2) 3) ;; (+ (* 1 2 3)) ;; (+ (* 1) 2 3)
</span>  2
  3
<span class="code-attr-keyword">if</span> (yes):
  <span class="code-attr-string">"ye"</span>
  <span class="code-attr-string">"s"</span>

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ブロックの明示
</span><span class="code-attr-comment-block">;; 
</span><span class="code-attr-comment-block">;; #コア機能  #拡張機能  #重要度 75%  #影響度 0%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ブロックを`()`, `[]`, `{}`で明示する
</span><span class="code-attr-comment-block">;; if-else構文の実現に必要
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">; = v (+ 1 2)
</span>= v (
  + 1 2
)
<span class="code-attr-comment-block">; = v (+ 1 2)
</span>= v (
+ 1 2)
<span class="code-attr-comment-block">; = v (# (= a 1) (+ a 2))
</span>= v {
  = a 1
  + a 2
}
<span class="code-attr-keyword">do</span> v  <span class="code-attr-comment-block">; 3
</span>
<span class="code-attr-keyword">if</span> yes (
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"yes"</span>
) (
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"no"</span>
)

<span class="code-attr-keyword">if</span> yes (
  = r <span class="code-attr-string">"yes"</span>
  <span class="code-attr-keyword">print</span> r
) <span class="code-attr-keyword">else</span>: [
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"no"</span>
]

<span class="code-attr-keyword">func</span> hello (world) {
  = str <span class="code-attr-string">"hello"</span>
  <span class="code-attr-keyword">print</span> str <span class="code-attr-string">" "</span> world
}
hello <span class="code-attr-string">"world"</span>  <span class="code-attr-comment-block">; "hello world"
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ブロックの明示（拡張）
</span><span class="code-attr-comment-block">;; 
</span><span class="code-attr-comment-block">;; 開始括弧`(`, `[`, `{`を関数式として解釈するコア機能
</span><span class="code-attr-comment-block">;; 終わり括弧までを一つの式として解釈させる
</span><span class="code-attr-comment-block">;; ヒアドキュメントの実現に必要
</span><span class="code-attr-comment-block">;; ユーザ定義を可能とするために必要
</span><span class="code-attr-comment-block">;; 可変長演算子への応用・統合も視野に入れる
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">; var v = "&lt;h1&gt;heading&lt;/h1&gt;\n&lt;p&gt;paragraph&lt;/p&gt;";
</span>= v <span class="code-attr-string">"""</span>
&lt;h1&gt;heading&lt;/h1&gt;
&lt;p&gt;paragraph&lt;/p&gt;
<span class="code-attr-string">"""</span>
<span class="code-attr-comment-block">; var v = [{name: "bob", age: 65}, {name: "tom", age: 9}];
</span>= v ((
  ---
    <span class="code-attr-label">name</span>: <span class="code-attr-string">"bob"</span>
    <span class="code-attr-label">age</span>:  65
  ---
    <span class="code-attr-label">name</span>: <span class="code-attr-string">"tom"</span>
    <span class="code-attr-label">age</span>:  9
))

= __builtin__.fn_paired[<span class="code-attr-string">"{}"</span>] (~~)
{<span class="code-attr-keyword">echo</span> <span class="code-attr-string">"a"</span>}  <span class="code-attr-comment-block">; ~~ echo "a"
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 遅延評価式のスコープ
</span><span class="code-attr-comment-block">;;  - 案１：遅延評価式の動的スコープは元スコープ基準
</span><span class="code-attr-comment-block">;;  - 案２：遅延評価式の動的スコープは式評価時のスコープ
</span>= that (<span class="code-attr-keyword">if</span> yes <span class="code-attr-type">this</span>)
== that <span class="code-attr-type">this</span>  <span class="code-attr-comment-block">; true （案１）
</span>== that <span class="code-attr-type">this</span>  <span class="code-attr-comment-block">; false（案２）
</span>(fn ()
  {<span class="code-attr-keyword">echo</span> _0} 2  <span class="code-attr-comment-block">; 1（案１）
</span>  {<span class="code-attr-keyword">echo</span> _0} 2  <span class="code-attr-comment-block">; 2（案２）
</span>)(1)

<span class="code-attr-comment-block">;; 影響（案１）
</span><span class="code-attr-comment-block">;;  - DSLの実現が困難
</span><span class="code-attr-keyword">func</span> markdown (...)
  = ary []
  = (#) fn (head) ary.push (+ <span class="code-attr-string">"&lt;h1&gt;"</span> <span class="code-attr-method">Serialize</span>(head) <span class="code-attr-string">"&lt;/h1&gt;"</span>)
  = (-) fn (item) ary.push (+ <span class="code-attr-string">"&lt;li&gt;"</span> <span class="code-attr-method">Serialize</span>(item) <span class="code-attr-string">"&lt;/li&gt;"</span>)
  <span class="code-attr-keyword">for</span>.<span class="code-attr-method">each</span>(i ...)
    = (#i).__prototype__[<span class="code-attr-string">"#"</span>] (#)
    = (#i).__prototype__[<span class="code-attr-string">"-"</span>] (-)
    <span class="code-attr-method">i</span>()
  join  <span class="code-attr-label">separator</span>:<span class="code-attr-string">"\n"</span>
       <span class="code-attr-label">terminator</span>:<span class="code-attr-string">""</span>
            <span class="code-attr-label">items</span>:ary

<span class="code-attr-comment-block">; "&lt;h1&gt;Heading&lt;/h1&gt;\n&lt;li&gt;list item&lt;/li&gt;"
</span>markdown
  # <span class="code-attr-object">Heading</span>
  - list item

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; カテゴリー式、グループ式
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 50%  #影響度 25%（演算子の構文規則）
</span><span class="code-attr-comment-block">;; #関連 [#チェインケース]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 式のサブ機能を実現する
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  `-`演算子をカテゴリ参照演算子として活用
</span><span class="code-attr-comment-block">;;     クラスのクラスメソッドを呼び出す（案１）
</span><span class="code-attr-comment-block">;;        `::`との競合
</span><span class="code-attr-comment-block">;;     クラスのインスタンスメソッドを呼び出す（案２）
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  同等の機能はメンバ参照演算子`.`を活用して実現することもできる #重要度 -25%
</span><span class="code-attr-comment-block">;;     ただしファンクタによる実装が必要
</span><span class="code-attr-comment-block">;;
</span>
loop-3 <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"a"</span> <span class="code-attr-comment-block">; "aaa"
</span>
<span class="code-attr-keyword">while</span>-infinite
  <span class="code-attr-keyword">for</span>-in i [1 2]
    <span class="code-attr-keyword">if</span> (= i 1) <span class="code-attr-keyword">for</span>-<span class="code-attr-keyword">continue</span>
    <span class="code-attr-keyword">if</span> (= i 2) <span class="code-attr-keyword">while</span>-<span class="code-attr-keyword">break</span>

<span class="code-attr-keyword">class</span> assert
  :<span class="code-attr-method">eq</span>(a b) __builtin__.<span class="code-attr-method">assert</span>(= a b)
<span class="code-attr-keyword">func</span> <span class="code-attr-method">assert</span>(#expr) __builtin__.<span class="code-attr-method">assert</span>(expr)

assert = 1 2
assert-eq 1 2

<span class="code-attr-comment-block">;; フリー関数への転送
</span><span class="code-attr-string">"a"</span>-<span class="code-attr-keyword">print</span>     <span class="code-attr-comment-block">;; print(self)      ;; self == "a"
</span><span class="code-attr-string">"a"</span>-<span class="code-attr-keyword">print</span> <span class="code-attr-string">"b"</span> <span class="code-attr-comment-block">;; print(self, "b")
</span><span class="code-attr-string">"s"</span>-length    <span class="code-attr-comment-block">; 9
</span><span class="code-attr-string">"s"</span>.length    <span class="code-attr-comment-block">; 1
</span>
fn <span class="code-attr-method">length</span>(s) 9
fn <span class="code-attr-label">Any</span>::<span class="code-attr-method">__doesNotUnderstand__</span>(msg ...args)
  <span class="code-attr-keyword">if</span>-eq <span class="code-attr-string">"Function"</span> typeof-msg
    <span class="code-attr-method">msg</span>(<span class="code-attr-type">self</span> ...args)
    <span class="code-attr-method">__UNIMPLEMENTED__</span>(<span class="code-attr-type">self</span> msg ...args)

<span class="code-attr-comment-block">;; 関数呼び出し式としての応用
</span>typeof-<span class="code-attr-string">"a"</span> <span class="code-attr-comment-block">; "String"
</span>typeof-999 <span class="code-attr-comment-block">; "Number"
</span><span class="code-attr-comment-block">; 影響範囲 ; 整合性 ; 合成関数への応用も視野に入れる #TODO
</span>typeof-<span class="code-attr-keyword">print</span> <span class="code-attr-comment-block">; "(Operator name:'typeof')" ;; print(typeof) ;; ???
</span><span class="code-attr-keyword">print</span>-typeof <span class="code-attr-comment-block">; "(Function name:'print')"  ;; print(typeof) ;; ???
</span>typeof=<span class="code-attr-keyword">print</span> <span class="code-attr-comment-block">; "(Function name:'print')"  ;; typeof(print) ;; ???
</span>:<span class="code-attr-keyword">print</span> <span class="code-attr-string">"a"</span>
typeof-<span class="code-attr-keyword">print</span> <span class="code-attr-comment-block">;; "String"   ;; ???
</span>typeof=<span class="code-attr-keyword">print</span> <span class="code-attr-comment-block">;; "Function" ;; ???
</span><span class="code-attr-comment-block">; 代替記法 ;; 関連: [#インライン・インデント #`|`演算子, `\`演算子の用途考察]
</span>assert\eq 1 2
assert~eq 1 2
<span class="code-attr-label">assert</span>:eq 1 2 <span class="code-attr-comment-block">; `Key:Any`型と競合
</span>assert|eq 1 2
assert.eq 1 2 <span class="code-attr-comment-block">; TODO: 名前衝突と優先順位
</span>
<span class="code-attr-comment-block">;; 関数オブジェクトへの応用
</span>[97 98].<span class="code-attr-method">map</span>{toUpperCase-toCharacter} <span class="code-attr-comment-block">; ['A' 'B']
</span>[97 98].<span class="code-attr-method">map</span>{toCharacter/toUpperCase} <span class="code-attr-comment-block">; ['A' 'B']
</span>[97 98].<span class="code-attr-method">map</span>{toUpperCase\toCharacter} <span class="code-attr-comment-block">; ['A' 'B']
</span>
join <span class="code-attr-character">'-'</span> map&lt;toS&gt;\reverse\sort [2 1]     <span class="code-attr-comment-block">; "1-2"
</span><span class="code-attr-character">'-'</span>.join (sort/reverse/map&lt;toS&gt; [2 1])   <span class="code-attr-comment-block">; "1-2" ;; 逐次呼び出しの遅延評価
</span>join <span class="code-attr-character">'-'</span>, sort/reverse/map&lt;toS&gt; [2 1]
join <span class="code-attr-character">'-'</span> (map&lt;toS&gt;..reverse..sort [2 1]) <span class="code-attr-comment-block">; "1-2"
</span>
expression `\(expr)..\(expr)` (a b) ~~(x) a (b x)
  
<span class="code-attr-comment-block">;; パイプライン
</span>:pipes toCharacter|toUpperCase
9 pipes|<span class="code-attr-keyword">print</span> <span class="code-attr-comment-block">; "A"
</span>9 toCharacter/toUpperCase/<span class="code-attr-keyword">print</span> <span class="code-attr-comment-block">; "A"
</span>
<span class="code-attr-comment-block">;; 変数への応用
</span>= margin-left  25
= margin-right 25
assert-eq  margin  {:left 25 :right 25}
assert-eq  margin- {<span class="code-attr-label">margin-left</span>: 25 <span class="code-attr-label">margin-right</span>: 25}

<span class="code-attr-comment-block">;; メンバ関数への応用
</span><span class="code-attr-keyword">func</span> <span class="code-attr-object">String</span>-size ()      <span class="code-attr-type">self</span>.length
<span class="code-attr-keyword">func</span> <span class="code-attr-object">String</span>-substr ()    <span class="code-attr-type">self</span>[$0, $1]
<span class="code-attr-keyword">func</span> <span class="code-attr-object">String</span>-substring () <span class="code-attr-type">self</span>[$0..$1]

<span class="code-attr-string">"12345"</span>.size            <span class="code-attr-comment-block">; 5
</span><span class="code-attr-string">"12345"</span>.<span class="code-attr-method">substr</span>(2 3)    <span class="code-attr-comment-block">; 345
</span><span class="code-attr-string">"12345"</span>.<span class="code-attr-method">substring</span>(2 3) <span class="code-attr-comment-block">; 3
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 暗黙のブロック
</span><span class="code-attr-comment-block">;; 
</span><span class="code-attr-comment-block">;; #拡張機能  #重要度 25%  #影響度 10%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; オペランドを必要とするオペレータが単独で使用された場合、
</span><span class="code-attr-comment-block">;; 次の行の式をそのオペレータに対応するオペランドとして解釈する
</span><span class="code-attr-comment-block">;; オペランドの探索は空行や同一オペランドが出現するまで繰り返される
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">; + 1 2
</span>+
1
2
<span class="code-attr-comment-block">; (if 1 "then" "else") (if 0 "then" "else")
</span><span class="code-attr-keyword">if</span>
1
<span class="code-attr-string">"then"</span>
<span class="code-attr-string">"else"</span>
<span class="code-attr-keyword">if</span>
0
<span class="code-attr-string">"then"</span>
<span class="code-attr-string">"else"</span>

<span class="code-attr-comment-block">; {members: [{name:"bob" age:65} {name:"tom" age:9}]}
</span><span class="code-attr-label">members</span>:
------------
<span class="code-attr-label">name</span>: <span class="code-attr-string">"bob"</span>
<span class="code-attr-label">age</span>:  65
------------
<span class="code-attr-label">name</span>: <span class="code-attr-string">"tom"</span>
<span class="code-attr-label">age</span>:  9

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 遅延評価
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 実引数は式として渡される
</span><span class="code-attr-comment-block">;; 式は関数側で遅延評価される
</span><span class="code-attr-comment-block">;; 式の評価は仮引数側で自動的に行われる
</span><span class="code-attr-comment-block">;; 仮引数名に前置`#`を付与することで式の評価を保留することができる
</span><span class="code-attr-comment-block">;;  - 式中に仮引数名が出現した段階で評価される
</span><span class="code-attr-comment-block">;;  - 式中に出現した仮引数名が前置`#`されていた場合は式を返す
</span><span class="code-attr-comment-block">;;
</span>
= foo fn (a)   <span class="code-attr-comment-block">; この段階でaが評価される
</span>        a      <span class="code-attr-comment-block">; aには評価結果が格納されている
</span>foo + 1 2      <span class="code-attr-comment-block">; 3
</span>
<span class="code-attr-comment-block">;; 仮引数の先頭が`#`で始まる場合は式の評価を保留する
</span>= foo fn (#a)  <span class="code-attr-comment-block">; 評価されない
</span>        #a     <span class="code-attr-comment-block">; aは式
</span>foo + 1 2      <span class="code-attr-comment-block">; + 1 2
</span>
<span class="code-attr-comment-block">;; 本文中で#が省略された場合は式の展開・評価が行われる
</span>= foo fn (#a)  <span class="code-attr-comment-block">; 評価されない
</span>        a      <span class="code-attr-comment-block">; 評価される
</span>foo + 1 2      <span class="code-attr-comment-block">; 3
</span>
<span class="code-attr-comment-block">;; if文はこの仕組みを用いて実装することができる
</span><span class="code-attr-keyword">func</span> <span class="code-attr-keyword">if</span> (cond #then #<span class="code-attr-keyword">else</span>)
       ? cond #then #<span class="code-attr-keyword">else</span>
<span class="code-attr-keyword">if</span> <span class="code-attr-type">nil</span> (<span class="code-attr-keyword">print</span> <span class="code-attr-string">"a"</span>) (<span class="code-attr-keyword">print</span> <span class="code-attr-string">"b"</span>)  <span class="code-attr-comment-block">; "b"
</span>
<span class="code-attr-comment-block">;; この仕組みで独自のキーワードを処理することも可能になる
</span>= <span class="code-attr-keyword">if</span> fn (c #then #t #<span class="code-attr-keyword">else</span> #e)
    ? c
      ? (= #then <span class="code-attr-label">then</span>:) #t #then)
      ? (= #<span class="code-attr-keyword">else</span> <span class="code-attr-keyword">else</span>:) #e #<span class="code-attr-keyword">else</span>)
<span class="code-attr-keyword">if</span> <span class="code-attr-type">nil</span>
  <span class="code-attr-label">then</span>: <span class="code-attr-keyword">print</span> <span class="code-attr-string">"yes"</span>
  <span class="code-attr-keyword">else</span>: <span class="code-attr-keyword">print</span> <span class="code-attr-string">"no"</span>

<span class="code-attr-comment-block">;; この仕組みで短絡評価の実現が可能になる
</span><span class="code-attr-keyword">func</span> logicalAND (#a #b)  <span class="code-attr-keyword">if</span> a #b #a
<span class="code-attr-keyword">func</span> logicalOR  (#a #b)  <span class="code-attr-keyword">if</span> a #a #b
logicalOR (logicalAND (<span class="code-attr-keyword">echo</span> <span class="code-attr-string">"1"</span>) no)  (<span class="code-attr-keyword">echo</span> <span class="code-attr-string">"2"</span>) <span class="code-attr-comment-block">; 12
</span>logicalOR (logicalAND (<span class="code-attr-keyword">echo</span> <span class="code-attr-string">"1"</span>) yes) (<span class="code-attr-keyword">echo</span> <span class="code-attr-string">"2"</span>) <span class="code-attr-comment-block">; 1
</span>
<span class="code-attr-comment-block">;; この仕組みで演算子の優先順位を実現することが可能になる
</span><span class="code-attr-keyword">class</span> <span class="code-attr-object">Number</span>
  <span class="code-attr-keyword">func</span> (+) (#expr)
    <span class="code-attr-keyword">if</span> &amp;&amp; == <span class="code-attr-string">"Expression"</span>  typeof #expr
          == <span class="code-attr-string">"Number"</span>      typeof #expr[0]
          == <span class="code-attr-string">"Operator"</span>    typeof #expr[1]
          || == (*) #expr[1]
             == (/) #expr[1]
      + <span class="code-attr-type">self</span>   expr <span class="code-attr-comment-block">; (+ 1 (2.* 3)) --&gt; (+ 1 6)
</span>      + <span class="code-attr-type">self</span> ##expr <span class="code-attr-comment-block">; (+ 3 2 - 3)   --&gt; (+ 3 2).- 3
</span>1 + 2 * 3  <span class="code-attr-comment-block">; 7
</span>3 + 2 - 1  <span class="code-attr-comment-block">; 4
</span>
<span class="code-attr-comment-block">;; 課題 ;;
</span><span class="code-attr-comment-block">;; 遅延評価式中のthisをどう扱うか  #TODO
</span><span class="code-attr-comment-block">;;  案１ 遅延評価式独自の空間として扱う
</span><span class="code-attr-comment-block">;;  案２ 宣言時のスコープにリンクする
</span><span class="code-attr-comment-block">;;  案３ 動的スコープにリンクする
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 遅延評価の拡張
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #拡張機能  #重要度 89%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 遅延評価をデフォルトにする
</span><span class="code-attr-comment-block">;; 仮引数名の前置`#`も省略可能にする
</span><span class="code-attr-comment-block">;; 機能性と多様性、柔軟性ために必要
</span><span class="code-attr-comment-block">;; ただしデバッグがしづらくなる（代替案検討）
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 仮引数側の`#`省略時
</span><span class="code-attr-comment-block">;;  - 式の評価は仮引数が本文中に出現した際に一度だけ行われる
</span><span class="code-attr-comment-block">;;  - 本文中に出現する仮引数が前置`#`されていた場合は式を返す
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 仮引数側の`#`明示時
</span><span class="code-attr-comment-block">;;  - 式の評価は仮引数が本文中に出現する度に行われる
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; `#`省略時
</span><span class="code-attr-comment-block">;;
</span>= f fn (a)   <span class="code-attr-comment-block">; 評価されない
</span>        a    <span class="code-attr-comment-block">; 2（評価される）
</span>        #a   <span class="code-attr-comment-block">; ++i
</span>        a    <span class="code-attr-comment-block">; 2（前回評価値）
</span>        a    <span class="code-attr-comment-block">; 2（前回評価値）
</span>= i 1
f ++i        <span class="code-attr-comment-block">; 2
</span>
<span class="code-attr-comment-block">;; `#`明示時
</span><span class="code-attr-comment-block">;;
</span>= f fn (#a)  <span class="code-attr-comment-block">; 評価されない
</span>        a    <span class="code-attr-comment-block">; 2（評価される）
</span>        #a   <span class="code-attr-comment-block">; ++i
</span>        a    <span class="code-attr-comment-block">; 3（評価される）
</span>        a    <span class="code-attr-comment-block">; 4（評価される）
</span>= i 1
f ++i        <span class="code-attr-comment-block">; 4
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ブロックの解釈
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #拡張機能  #重要度 100%  #影響度 0%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; インデントの深さを関数名の幅基準にする拡張
</span><span class="code-attr-comment-block">;; インデントの数ではなくインデントの位置でブロックを表現する
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">; (add 1 2)
</span>add 1
    2
<span class="code-attr-comment-block">; (add 1 (+ 2 3) 4)
</span>add 1 + 2 3
    4
<span class="code-attr-comment-block">; (add 1 (+ 2 3 4))
</span>add 1 + 2 3
        4
<span class="code-attr-comment-block">;; 影響 ;;
</span>printDictionary :name <span class="code-attr-string">"mary"</span>
                :age  16
<span class="code-attr-comment-block">;; 対応案 ;;
</span>printDictionary (:name <span class="code-attr-string">"mary"</span>
                 :age  16)
printDictionary :name <span class="code-attr-string">"mary"</span>
                 age  16
printDictionary : name <span class="code-attr-string">"mary"</span>
                  age  16

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 静的スコープ
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 100%  #影響度 --%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; クロージャーの実現に必要
</span><span class="code-attr-comment-block">;;
</span>
= v 9
{<span class="code-attr-keyword">echo</span> v}()         <span class="code-attr-comment-block">; 9
</span>{<span class="code-attr-keyword">echo</span> _v}()        <span class="code-attr-comment-block">; 9
</span>{<span class="code-attr-keyword">echo</span> <span class="code-attr-type">this</span>.v}()    <span class="code-attr-comment-block">; 9
</span>{<span class="code-attr-keyword">echo</span> $<span class="code-attr-keyword">static</span>.v}() <span class="code-attr-comment-block">; 9
</span>{<span class="code-attr-keyword">echo</span> <span class="code-attr-type">this</span>[<span class="code-attr-string">"__static__"</span>].v}() <span class="code-attr-comment-block">; 9
</span>{ = v 8
  <span class="code-attr-keyword">echo</span> <span class="code-attr-type">this</span>.v
  <span class="code-attr-keyword">echo</span> __static__.v
}() <span class="code-attr-comment-block">; 89
</span>
<span class="code-attr-comment-block">;; 遅延評価式の静的スコープは元スコープ基準（検討中 #遅延評価式のスコープ）
</span>= v 1
<span class="code-attr-keyword">func</span> <span class="code-attr-keyword">do</span> (#f)
  = v 2
  f
<span class="code-attr-keyword">do</span> {<span class="code-attr-keyword">echo</span> v}  <span class="code-attr-comment-block">; 1
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 動的スコープ
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 100%  #影響度 --%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 変数宣言式／代入式を実現するために必要
</span><span class="code-attr-comment-block">;;  - varの独自定義を可能とする
</span><span class="code-attr-comment-block">;; classのメソッド宣言式を実現するために必要
</span><span class="code-attr-comment-block">;;  - func関数からclassのインスタンスへのアクセスを可能にする
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; varの実装
</span>= <span class="code-attr-type">var</span> fn (#name val) = $local[#name] val
<span class="code-attr-type">var</span> i 99  <span class="code-attr-comment-block">; = i 99
</span>i         <span class="code-attr-comment-block">; 99
</span><span class="code-attr-type">this</span>.i    <span class="code-attr-comment-block">; 99
</span><span class="code-attr-type">this</span>[<span class="code-attr-string">"i"</span>] <span class="code-attr-comment-block">; 99
</span>
<span class="code-attr-comment-block">;; 関数宣言式の実装
</span>= <span class="code-attr-keyword">func</span> ~~ (#name #param #...)
  = $local[#name] (__builtin__[<span class="code-attr-string">"defun"</span>] #name #param #...)

<span class="code-attr-keyword">func</span> add () + $0 $1
#<span class="code-attr-type">this</span>[<span class="code-attr-string">"add"</span>]  <span class="code-attr-comment-block">; + $0 $1
</span>
<span class="code-attr-comment-block">;; メソッド宣言式の実装
</span><span class="code-attr-keyword">class</span> X
  <span class="code-attr-keyword">func</span> get () 99
= i <span class="code-attr-method">X</span>()
i.<span class="code-attr-method">get</span>()   <span class="code-attr-comment-block">; 99
</span>
<span class="code-attr-comment-block">;; 備考 -- クラス宣言式の内部実装案
</span><span class="code-attr-keyword">func</span> <span class="code-attr-keyword">class</span> (attr ...members)
  :__className__ attr.0
  :__isa__       {<span class="code-attr-label">__className__</span>: (?? attr.1 <span class="code-attr-object">Object</span>)}
  :__ivars__     []
  <span class="code-attr-keyword">for</span> in #m ...members
    __ivars__.push (#m <span class="code-attr-type">this</span>)
  <span class="code-attr-keyword">return</span> <span class="code-attr-method">Class</span>(<span class="code-attr-type">this</span>)
  <span class="code-attr-comment-block">;; #members[0]  ; (var v 9)
</span>  <span class="code-attr-comment-block">;; #members[1]  ; (func f () self.v)
</span>  <span class="code-attr-comment-block">;; #this["v"]   ; 9
</span>  <span class="code-attr-comment-block">;; #this["f"]   ; (~~ self.v)
</span>  <span class="code-attr-comment-block">;; assert == this (#this["f"]).__local__
</span>
<span class="code-attr-keyword">class</span> X
  <span class="code-attr-type">var</span> v 9
  <span class="code-attr-keyword">func</span> f () <span class="code-attr-type">self</span>.v

<span class="code-attr-comment-block">;; 備考 -- Class関数の内部実装
</span><span class="code-attr-keyword">func</span> <span class="code-attr-object">Class</span> (<span class="code-attr-keyword">class</span>)
  = that (__UNIMPLEMENTED__ <span class="code-attr-keyword">class</span>)
  each <span class="code-attr-keyword">class</span>.__ivars__
    = (#_)[<span class="code-attr-string">"__static__"</span>] that
  <span class="code-attr-keyword">return</span> that
  
<span class="code-attr-comment-block">;; 備考 -- $localの内部実装
</span>
<span class="code-attr-comment-block">; 案１ - 糖衣構文
</span>$local <span class="code-attr-comment-block">; this["__local__"]
</span>$typo  <span class="code-attr-comment-block">; this["__typo__"]
</span>
= <span class="code-attr-type">var</span>[<span class="code-attr-string">"__local__"</span>] <span class="code-attr-type">this</span>
<span class="code-attr-type">var</span> i 99

<span class="code-attr-comment-block">; 案２ - 新たな仕様として[#暗黙のthis渡し]を加える  #TODO
</span>
<span class="code-attr-comment-block">;; 暗黙のthis渡し
</span><span class="code-attr-keyword">func</span> f () $$.v
= v 9
(a 1)      <span class="code-attr-comment-block">; 9
</span><span class="code-attr-type">this</span>[<span class="code-attr-string">"v"</span>]  <span class="code-attr-comment-block">; 9
</span>
<span class="code-attr-comment-block">;; $localプロパティへの応用
</span><span class="code-attr-keyword">func</span> $local $$[<span class="code-attr-string">"__local__"</span>]
= v 9
<span class="code-attr-keyword">do</span> {
  $local.v          <span class="code-attr-comment-block">; 9
</span>  <span class="code-attr-type">this</span>[<span class="code-attr-string">"__local__"</span>] <span class="code-attr-comment-block">; 9
</span>}

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; selfとthis
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; クラスをコア機能に取り込む場合は以下の区別を行う
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; this: 関数オブジェクトが自身を参照するために使用
</span><span class="code-attr-comment-block">;; self: メソッドがクラスのインスタンスを参照するために使用
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; selfは静的スコープを用いて実装することができる
</span>= <span class="code-attr-type">self</span>    ~~ $$[<span class="code-attr-string">"__static__"</span>]
= <span class="code-attr-type">super</span>   ~~ $$[<span class="code-attr-string">"__static__"</span>][<span class="code-attr-string">"__isa__"</span>]

<span class="code-attr-keyword">class</span> X
  = v 99
  <span class="code-attr-keyword">func</span> f ()
    <span class="code-attr-type">this</span>             <span class="code-attr-comment-block">; f関数への参照
</span>    <span class="code-attr-type">self</span>             <span class="code-attr-comment-block">; Xインスタンスへの参照
</span>    <span class="code-attr-type">this</span>.__static__  <span class="code-attr-comment-block">; Xインスタンスへの参照
</span>    __static__       <span class="code-attr-comment-block">; Xインスタンスへの参照
</span>    $<span class="code-attr-keyword">static</span>          <span class="code-attr-comment-block">; Xインスタンスへの参照（糖衣構文？）
</span>    
    = v 11
    v          <span class="code-attr-comment-block">; 11
</span>    _v         <span class="code-attr-comment-block">; 11? 99?（検討中）
</span>    <span class="code-attr-type">this</span>.v     <span class="code-attr-comment-block">; 11
</span>    <span class="code-attr-type">self</span>.v     <span class="code-attr-comment-block">; 99
</span>    $<span class="code-attr-keyword">static</span>.v  <span class="code-attr-comment-block">; 99
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; スコープチェーン
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 変数の捜索はまずスコープ内で行われる
</span><span class="code-attr-comment-block">;; 次に引数リスト
</span><span class="code-attr-comment-block">;; 次にthisオブジェクト
</span><span class="code-attr-comment-block">;; 次に静的スコープ（$static）から同じ手順で
</span><span class="code-attr-comment-block">;;   $static.スコープ内
</span><span class="code-attr-comment-block">;;   $static.引数リスト
</span><span class="code-attr-comment-block">;;   $static.thisオブジェクト
</span><span class="code-attr-comment-block">;;   $static.$static.スコープ内
</span><span class="code-attr-comment-block">;; へと捜索を繰り返す
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; クロージャーはこの仕組みで実現される
</span>= v 99
(~~ <span class="code-attr-keyword">print</span> v)() <span class="code-attr-comment-block">; "99"
</span>
<span class="code-attr-comment-block">;; selfの省略記法もこの仕組みで実現される
</span><span class="code-attr-keyword">class</span> X
  = v 99
  <span class="code-attr-keyword">func</span> f ()
    <span class="code-attr-type">self</span>.v <span class="code-attr-comment-block">; 99
</span>    v      <span class="code-attr-comment-block">; 99
</span>
<span class="code-attr-comment-block">;; 静的スコープとの関係
</span><span class="code-attr-keyword">func</span> foo (#f)
  = v 0
  f
= v 1
foo {<span class="code-attr-keyword">echo</span> v} <span class="code-attr-comment-block">; 1
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 式型
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 100%  #影響度 0%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 遅延評価式の内部表現を定める
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; `else`等のキーワードを関数側で識別するための仕組みが必要
</span><span class="code-attr-comment-block">;; 現状ではKey型の`else:`を明示的に渡す方法を採っている
</span><span class="code-attr-comment-block">;;`else`を`else:`のエイリアスする方法もあるが名前空間の汚染が問題となる
</span><span class="code-attr-comment-block">;; 式展開の段階で式をシンボル化またはKey化、文字列化するための汎用的な仕組みが求められる
</span><span class="code-attr-comment-block">;; これらの仕組みがあればDSL的に独自の機能を定義・制御することができる
</span><span class="code-attr-comment-block">;; これらの仕組みがあれば変数宣言式をユーザ定義可能にすることができる
</span><span class="code-attr-comment-block">;;
</span>= v 9
(#v).__name__ <span class="code-attr-comment-block">; v
</span>(#w).__name__ <span class="code-attr-comment-block">; w
</span>(#+).__name__ <span class="code-attr-comment-block">; + or __ADD__（検討中）
</span>(#8).__name__ <span class="code-attr-comment-block">; nil or __NUMBER__（実装依存？）
</span>(#{<span class="code-attr-keyword">echo</span> _}).__name__ <span class="code-attr-comment-block">; nil or __ANONYMOUS_FUNCTION__
</span>(#(+ 1 2)).__name__  <span class="code-attr-comment-block">; nil or __ANONYMOUS_FUNCTION__
</span>
(#v).__type__ <span class="code-attr-comment-block">; Variable
</span>(#w).__type__ <span class="code-attr-comment-block">; Undefined
</span>(#8).__type__ <span class="code-attr-comment-block">; Number
</span>(#+).__type__ <span class="code-attr-comment-block">; Operator
</span>(#<span class="code-attr-keyword">echo</span>).__type__     <span class="code-attr-comment-block">; Variable
</span>(#{<span class="code-attr-keyword">echo</span> _}).__type__ <span class="code-attr-comment-block">; Function
</span>(#(+ 1 2)).__type__  <span class="code-attr-comment-block">; Expression
</span>
(#:k).__name__  <span class="code-attr-comment-block">; k
</span>(#:k).__key__   <span class="code-attr-comment-block">; k:
</span>(#:k).__type__  <span class="code-attr-comment-block">; Key
</span>
(#v).__type__  <span class="code-attr-comment-block">; Variable
</span>(#v).__some__  <span class="code-attr-comment-block">; {:__name__ nil  :__type__ Number}
</span>(#w).__some__  <span class="code-attr-comment-block">; {:__name__ nil  :__type__ nil   }
</span>(#9).__some__  <span class="code-attr-comment-block">; nil
</span>(#<span class="code-attr-keyword">echo</span>).__some__  <span class="code-attr-comment-block">; {:__name__ nil  :__type__ Function}
</span>
<span class="code-attr-keyword">func</span> typeof (#t)
  <span class="code-attr-keyword">if</span> == <span class="code-attr-string">"Variable"</span> <span class="code-attr-method">String</span>((#t).__type__)
    <span class="code-attr-object">String</span> t.__some__.__type__
    <span class="code-attr-object">String</span> t.__type__

typeof v     <span class="code-attr-comment-block">; "Number"
</span>typeof <span class="code-attr-keyword">echo</span>  <span class="code-attr-comment-block">; "Function"
</span>
<span class="code-attr-keyword">func</span> <span class="code-attr-keyword">if</span> (cond #then #t)
  ? &amp;&amp; == <span class="code-attr-string">"Key"</span>   typeof #then
       == <span class="code-attr-string">"then"</span>  <span class="code-attr-object">String</span> #then
    t
    then
  
<span class="code-attr-keyword">if</span> yes then <span class="code-attr-string">"yes"</span>  <span class="code-attr-comment-block">; "yes"
</span><span class="code-attr-keyword">if</span> yes <span class="code-attr-string">"yes"</span>       <span class="code-attr-comment-block">; "yes"
</span><span class="code-attr-keyword">if</span> no  <span class="code-attr-string">"yes"</span>       <span class="code-attr-comment-block">; nil
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; インライン・インデント
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #拡張機能  #重要度 70%  #影響度 50%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; インデント区切り（タブまたは２文字以上の空白）を、
</span><span class="code-attr-comment-block">;; ブロックの区切りと見なす
</span><span class="code-attr-comment-block">;;
</span>+  1 2  3 4          <span class="code-attr-comment-block">; + (1 2) (3 4)
</span>*  + 1 2 3  + 3 4 5  <span class="code-attr-comment-block">; * (+ 1 2 3) (+ 3 4 5)
</span>* - 1  2             <span class="code-attr-comment-block">; * (- 1) 2
</span>? eq 1 2  3 4  <span class="code-attr-comment-block">; ? (eq 1 2) (3) (4)
</span>? eq 1 2 3 4   <span class="code-attr-comment-block">; ? (eq 1 2 3 4)
</span>
<span class="code-attr-comment-block">;; `|`演算子, `\`演算子の用途考察  #TODO
</span><span class="code-attr-comment-block">; ブロックの区切り文字としての利用
</span>+ (+ 1 2) (+ 2 3)
↓
+ |+ 1 2 |+ 2 3

+ \+ 1 2 \+ 2 3

<span class="code-attr-keyword">echo</span> : add 1 2 : mul 2 3 <span class="code-attr-comment-block">;; 75%
</span>
<span class="code-attr-keyword">echo</span> | add 1 2 | mul 2 3 <span class="code-attr-comment-block">;; 75% ;; パイプ処理、ラムダ式との整合性に難がある
</span>
<span class="code-attr-keyword">echo</span> \ add 1 2 \ mul 2 3 <span class="code-attr-comment-block">;; 75% ;; `\`演算子の用途次第（変数・仮引数での利用を検討中 -&gt; 前置記法）
</span>
<span class="code-attr-keyword">echo</span> /add 1 2 /mul 2 3   <span class="code-attr-comment-block">;; 75% ;; `\`とペアで検討。優先順位の多様性に関する
</span>
<span class="code-attr-keyword">echo</span> . add 1 2 . mul 2 3 <span class="code-attr-comment-block">;; 50% ;; #影響: メソッドチェーン、合成関数 #TODO: 両機能の統合
</span><span class="code-attr-keyword">echo</span>. add 1 2.toString          <span class="code-attr-comment-block">;; 前置と後置、中置で区別が必要
</span>             .append <span class="code-attr-character">'0'</span>
             .toInteger . 3     <span class="code-attr-comment-block">; "303"
</span>
<span class="code-attr-keyword">echo</span> $ add 1 2 $ mul 2 3 <span class="code-attr-comment-block">;; 25% ;; 影響: [#ラムダ宣言式の追加]
</span>
<span class="code-attr-keyword">echo</span> , add 1 2 , mul 2 3 <span class="code-attr-comment-block">;; 0%  ;; カンマ演算子と競合、位置関係が曖昧（第二引数以降の結合規則など）
</span>
<span class="code-attr-keyword">echo</span> @ add 1 2 @ mul 2 3 <span class="code-attr-comment-block">;; 0%  ;; 存在感、重みが強すぎる
</span>
<span class="code-attr-keyword">echo</span>  add 1 2  mul 2 3

<span class="code-attr-comment-block">;; 結合規則の区別
</span><span class="code-attr-keyword">echo</span> | add 1 2 | mul 2 3   <span class="code-attr-comment-block">; (echo) (add 1 2) (mul 2 3)
</span><span class="code-attr-keyword">echo</span> \ add 1 2 \ mul 2 3   <span class="code-attr-comment-block">; (echo (add 1 2 (mul 2 3)))
</span><span class="code-attr-keyword">echo</span>, add 1 2, mul 2 3     <span class="code-attr-comment-block">; (echo (add 1 2 (mul 2 3)))
</span>
<span class="code-attr-keyword">echo</span> \add 1 2 |mul 2 3     <span class="code-attr-comment-block">; (echo (add 1 2) (mul 2 3))
</span>
assert\eq <span class="code-attr-keyword">if</span>\eq 1 1 |yes |no ||yes

assert.eq <span class="code-attr-keyword">if</span>.eq 1 1 |yes |no ||yes <span class="code-attr-comment-block">;; 関連 [#カテゴリー式、グループ式]
</span>
assert-eq <span class="code-attr-keyword">if</span>-eq 1 1 |yes |no ||yes <span class="code-attr-comment-block">;; 関連 [#カテゴリー式、グループ式]
</span>
<span class="code-attr-comment-block">;; その他
</span><span class="code-attr-keyword">echo</span>. add 1 2, 3  <span class="code-attr-comment-block">; "5"
</span><span class="code-attr-keyword">echo</span>. add 1 2 . 3 <span class="code-attr-comment-block">; "33"
</span><span class="code-attr-keyword">echo</span>. add. sub 1 2 . 2  <span class="code-attr-comment-block">; "1"  ;; echo + (- 1 2) 2
</span><span class="code-attr-keyword">echo</span>. add. sub 2 1 .. 2 <span class="code-attr-comment-block">; "12" ;; echo +(- 2 1) 2
</span>
<span class="code-attr-comment-block">; 検証１
</span><span class="code-attr-keyword">echo</span> . add . sub 1 2 .. 2 <span class="code-attr-comment-block">; "1" (echo (+ (- 1 2) 2))
</span><span class="code-attr-keyword">echo</span>. add. sub 1 2 . 2    <span class="code-attr-comment-block">; "1"
</span><span class="code-attr-keyword">echo</span>\add\sub 1 2 \ 2      <span class="code-attr-comment-block">; "1"
</span><span class="code-attr-keyword">echo</span>\add\sub 2 1 \\ 2     <span class="code-attr-comment-block">; "12" (echo +(- 1 2) 2)
</span>
<span class="code-attr-keyword">echo</span> \add \sub 1 2\ 2     <span class="code-attr-comment-block">; "1"
</span><span class="code-attr-keyword">echo</span>. add (sub 1 2) 2     <span class="code-attr-comment-block">; "1"
</span>
<span class="code-attr-comment-block">; 検証２
</span><span class="code-attr-keyword">echo</span> add\1 2               <span class="code-attr-comment-block">; (echo (add 1 2)) ;; 関連: [#カテゴリー式、グループ式]
</span><span class="code-attr-keyword">echo</span> add\1 2 mul\2 3       <span class="code-attr-comment-block">; (echo (add 1 2 (mul 2 3)))
</span><span class="code-attr-keyword">echo</span> \add 1 2 \mul 2 3     <span class="code-attr-comment-block">; (echo (add 1 2) (mul 2 3))
</span><span class="code-attr-keyword">echo</span> \add 1 2 \ mul 2 3    <span class="code-attr-comment-block">; (echo (add 1 2) mul 2 3)
</span><span class="code-attr-keyword">echo</span> \add 1 2 \\mul 2 3    <span class="code-attr-comment-block">; (echo (add 1 2) mul 2 3)
</span><span class="code-attr-keyword">echo</span> \add 1 2\ \mul 2 3    <span class="code-attr-comment-block">; (echo (add 1 2) (mul 2 3))
</span>
<span class="code-attr-keyword">echo</span> <span class="code-attr-keyword">if</span>\eq 1 1 \ yes no \\ <span class="code-attr-string">"\n"</span> <span class="code-attr-comment-block">; "yes\n"
</span>
<span class="code-attr-comment-block">; `/`と`.`で結合規則を区別
</span><span class="code-attr-keyword">echo</span> \ add 1 2 \ sub 3 <span class="code-attr-comment-block">; (echo (add 1 2) (sub 3))
</span><span class="code-attr-keyword">echo</span> . add 1 2 . sub 3 <span class="code-attr-comment-block">; (echo (add 1 2 (sub 3)))
</span><span class="code-attr-comment-block">; 前置記法で結合規則を明示
</span><span class="code-attr-keyword">echo</span> \ add 1 2 \sub 3  <span class="code-attr-comment-block">; (echo (add 1 2 (sub 3))) ;; ややこしい
</span><span class="code-attr-keyword">echo</span> \add 1 2 \sub 3   <span class="code-attr-comment-block">; (echo (add 1 2) (sub 3)) ;; ややこしい
</span><span class="code-attr-keyword">echo</span> .add 1 2 .sub 3   <span class="code-attr-comment-block">; (echo 1.add(2 3.sub))    ;; 関連: [#代理関数呼び出し]
</span><span class="code-attr-keyword">echo</span> .add 1 2 ..sub 3  <span class="code-attr-comment-block">; (echo 1.add(2) (sub 3))
</span>
<span class="code-attr-comment-block">; 前置のほうが明確
</span><span class="code-attr-keyword">echo</span> .add 1 2 <span class="code-attr-comment-block">; "3"  ;; echo add(1 2) ;; 関連: [#代理関数呼び出し] ;; "s".echo
</span><span class="code-attr-string">"a"</span> .add <span class="code-attr-string">"b"</span> <span class="code-attr-string">"c"</span> <span class="code-attr-comment-block">; "abc" ;; "a".add("b" "c")
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 演算子束縛
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #拡張機能  #重要度 50%  #影響度 25%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 後置された演算子関数呼び出し式の結果を前方の関数呼び出し式へ束縛する
</span><span class="code-attr-comment-block">;;
</span>assert! 1 2   <span class="code-attr-comment-block">; assert (! 1 2)
</span>assert= 1 1   <span class="code-attr-comment-block">; assert (= 1 1)
</span><span class="code-attr-comment-block">;; 応用 - 前提仕様[#演算子の結合規則]
</span><span class="code-attr-keyword">print</span>+ 1 2 3 <span class="code-attr-comment-block">; (print (+ 1 2) 3)
</span><span class="code-attr-keyword">if</span>= 1 1 <span class="code-attr-string">"yes"</span> <span class="code-attr-string">"no"</span>

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 演算子の前置記法
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 75%  #影響度 25%
</span><span class="code-attr-comment-block">;;
</span>+ -1 2   <span class="code-attr-comment-block">; (+ (- 1) 2)
</span>= *p &amp;v  <span class="code-attr-comment-block">; int *p = &amp;v;
</span>
<span class="code-attr-comment-block">;; ラムダ式の糖衣構文`~`と区別できるようにする（検討中）
</span>= bnot ~ (bit) ~bit
bnot 0     <span class="code-attr-comment-block">; -1
</span>~(bnot 0)  <span class="code-attr-comment-block">; 0
</span>~ (bnot 0) <span class="code-attr-comment-block">; fn () (bnot 0)
</span>*(1 2 3)   <span class="code-attr-comment-block">; 1
</span>**(1 2 3)  <span class="code-attr-comment-block">;       -- 検討中（可変長演算子）
</span>           <span class="code-attr-comment-block">; **(1 2 3) ; 2     案１
</span>           <span class="code-attr-comment-block">; **(1 2 3) ; (2 3) 案２
</span>+(1 2 3)   <span class="code-attr-comment-block">; (2 3)
</span>*+(1 2 3)  <span class="code-attr-comment-block">; 2     -- 検討中（演算子の逐次適用）
</span>           <span class="code-attr-comment-block">; `+`演算子の挙動案 #TODO
</span>           <span class="code-attr-comment-block">; assert == +1      2
</span>           <span class="code-attr-comment-block">; assert == +"abc"  "bc"
</span>           <span class="code-attr-comment-block">; +"2"  ???: ""
</span>           <span class="code-attr-comment-block">; +"2"  ???: 2
</span>1 +2       <span class="code-attr-comment-block">; (1 (+ 2))
</span>1 + 2      <span class="code-attr-comment-block">; (1 (+) 2)
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 前置呼び出し
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #拡張機能  #重要度 100%  #影響度 0%
</span><span class="code-attr-comment-block">;; #関連仕様 [#演算子の前置記法]
</span><span class="code-attr-comment-block">;;
</span>+(1 2)     <span class="code-attr-comment-block">; (+ 1 2)
</span>-1         <span class="code-attr-comment-block">; (- 1)
</span><span class="code-attr-method">print</span>(1 2) <span class="code-attr-comment-block">; (print 1 2)
</span><span class="code-attr-comment-block">;; 影響
</span>^(a b) + a b  <span class="code-attr-comment-block">; (fn (a) b)  (+ a b)
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 前置呼び出し昇格
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #拡張機能  #重要度 9%  #影響度 100%
</span><span class="code-attr-comment-block">;; #前提仕様 [#前置呼び出し]
</span><span class="code-attr-comment-block">;; #代替仕様 [#式展開の原則]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 前置呼び出しされた式をオペレータとして解釈させる
</span><span class="code-attr-comment-block">;; - 前置呼び出しされた式はオペレータに昇格する
</span><span class="code-attr-comment-block">;; - 続く式はオペランドとして解釈される
</span><span class="code-attr-comment-block">;;
</span>~[a b] + a b  <span class="code-attr-comment-block">; (fn (a b) + a b)
</span>^[a b] - a b  <span class="code-attr-comment-block">; (fn (a b) - a b)
</span>  
<span class="code-attr-comment-block">;; 展開規則
</span>= d ~~ #arguments
d[a b]   <span class="code-attr-comment-block">; [Array([a b])]
</span><span class="code-attr-method">d</span>(a b)   <span class="code-attr-comment-block">; [Variable(a) Variable(b)]
</span><span class="code-attr-method">d</span>{a b}   <span class="code-attr-comment-block">; [Function(fn () (a b))]
</span>d&lt;a b&gt;   <span class="code-attr-comment-block">; [Function(fn () (a b))]
</span>
<span class="code-attr-comment-block">;; 辞書型宣言用の糖衣構文はこの仕様により実現が可能となる
</span>:a 1 :b 2     <span class="code-attr-comment-block">; (: a 1 (: b 2))
</span>  
<span class="code-attr-comment-block">;; 影響
</span><span class="code-attr-keyword">print</span> -1 2    <span class="code-attr-comment-block">; print (- 1 2)
</span><span class="code-attr-keyword">print</span> <span class="code-attr-method">f</span>() 2   <span class="code-attr-comment-block">; print (f() 2)
</span>== :key val   <span class="code-attr-comment-block">; == (: key val)
</span><span class="code-attr-keyword">func</span> <span class="code-attr-method">f</span>(a) <span class="code-attr-type">nil</span> <span class="code-attr-comment-block">; func (f a nil)
</span>  
<span class="code-attr-comment-block">;; 対応案
</span><span class="code-attr-keyword">print</span> -1, 2   <span class="code-attr-comment-block">; print -1 2
</span>== <span class="code-attr-label">key</span>: val <span class="code-attr-comment-block">; = key: key  ;; 後置／前置で異なる結合規則を取り入れる
</span>                          <span class="code-attr-comment-block">;; 参考：[#段落結合]
</span><span class="code-attr-comment-block">; [#式展開の原則]
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 逐次呼び出し
</span><span class="code-attr-comment-block">;; オペレーターチェーン
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 75%  #影響度 0%
</span><span class="code-attr-comment-block">;;
</span>fun a <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"a"</span>
fun b <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"b"</span>
a|b    <span class="code-attr-comment-block">; "ba" -- 案１
</span>a|b    <span class="code-attr-comment-block">; "ab" -- 案２
</span>a-b    <span class="code-attr-comment-block">;      -- 案３（影響: [#名前解決]）
</span>a&lt;&gt;b   <span class="code-attr-comment-block">;      -- 案４（関連: [#部分適用式]）
</span>a&lt;b    <span class="code-attr-comment-block">; "ba"
</span>a&gt;b    <span class="code-attr-comment-block">; "ab"
</span>a-&gt;b   <span class="code-attr-comment-block">; "ab"
</span>a&lt;-b   <span class="code-attr-comment-block">; "ba"
</span><span class="code-attr-comment-block">;; 戻り値の受け渡しが行われる
</span><span class="code-attr-keyword">func</span> a () + 1 _
<span class="code-attr-keyword">func</span> b () + 2 _
a|b 0  <span class="code-attr-comment-block">;  3
</span>
<span class="code-attr-comment-block">;; プロパティ呼び出しへの応用も視野に入れる
</span>99.nod.toS <span class="code-attr-comment-block">; 99.numberOfDigits().toString()
</span>99.toS.len <span class="code-attr-comment-block">; 99.toString().length()
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 名前解決
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #拡張機能  #重要度 60%  #影響度 100%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; キャメルケースとスネークケースとチェインケースに相互互換性を持たせる
</span><span class="code-attr-comment-block">;;
</span>exte <span class="code-attr-object">Number</span> <span class="code-attr-keyword">func</span> numberOfDigits () <span class="code-attr-object">Integer</span> (+ 1 <span class="code-attr-object">Math</span>.<span class="code-attr-method">log10</span>(<span class="code-attr-type">self</span>))

99.numberOfDigits   <span class="code-attr-comment-block">; 2
</span>99.number-of-digits <span class="code-attr-comment-block">; 2
</span>99.number_of_digits <span class="code-attr-comment-block">; 2
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 部分適用式
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; オペレータに対する後置記法を関数の部分適用式として解釈する
</span><span class="code-attr-comment-block">;; 部分適用やカリー化の糖衣構文を実現する事ができる
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">; map (fn (a) * 2 a}) [1 2 3]
</span><span class="code-attr-method">map</span>{* 2 _} [1 2 3]    <span class="code-attr-comment-block">; [2 4 6]
</span>map&lt;* 2 _&gt; [1 2 3]    <span class="code-attr-comment-block">; [2 4 6]
</span>map&lt;* 2&gt;   [1 2 3]    <span class="code-attr-comment-block">; [2 4 6]
</span>map&lt;+ <span class="code-attr-string">"0"</span>&gt; [1 2 3]    <span class="code-attr-comment-block">; ["01" "02" "03"]
</span><span class="code-attr-method">sort</span>{&gt;}    [1 2 3]    <span class="code-attr-comment-block">; [3 2 1]
</span><span class="code-attr-method">filter</span>{&lt; 1} [1 2 3]   <span class="code-attr-comment-block">; [2 3]   ;; 関連: [#部分適用]
</span>reverse|map&lt;* 2&gt;<span class="code-attr-method">filter</span>{&lt; 1} (1 2 3) <span class="code-attr-comment-block">; (6 4) -- 案１（関連: [#前置呼び出し昇格] [#逐次呼び出し]）
</span><span class="code-attr-method">filter</span>{&lt; 1}map&lt;* 2&gt;|reverse (1 2 3) <span class="code-attr-comment-block">; (6 4) -- 案２（関連: [#前置呼び出し昇格] [#逐次呼び出し]）
</span>= f <span class="code-attr-method">sort</span>{&gt;}
f [4 5 6]     <span class="code-attr-comment-block">; [6 5 4]
</span>f [7 8 9]     <span class="code-attr-comment-block">; [9 8 7]
</span>= f {add&lt;$0&gt;}
= g (f 9)     <span class="code-attr-comment-block">; add&lt;9&gt;
</span>g 1           <span class="code-attr-comment-block">; 10
</span>
<span class="code-attr-comment-block">;; 応用
</span><span class="code-attr-comment-block">;;   コードの多様性を実現する用途にも活用できる
</span>[1 2 3].take 2   <span class="code-attr-comment-block">; [1 2]
</span>[1 2 3].<span class="code-attr-method">take</span>{&gt;2} <span class="code-attr-comment-block">; [1]
</span>= f (&gt;3)
[1 2 3].take f   <span class="code-attr-comment-block">; [1 2] ; 曖昧（fは数値なのか関数なのか）
</span>[1 2 3].<span class="code-attr-method">take</span>{f}  <span class="code-attr-comment-block">; [1 2] ; 明確
</span><span class="code-attr-comment-block">;;   このようなセマンティクスの明確化によって
</span><span class="code-attr-comment-block">;;   オーバーロードの欠点を補うことも可能となる
</span>
<span class="code-attr-comment-block">;; 備考
</span><span class="code-attr-comment-block">;;   本仕様は[#前置呼び出し昇格]の仕組みで代用することもできる
</span><span class="code-attr-keyword">func</span> map (f a)
  <span class="code-attr-keyword">switch</span> _arguments.length
    (0)  #map
    (1)  ~~ [aa] map f aa
    (2)  <span class="code-attr-keyword">for</span>&lt;f&gt; a
    (_)  map f [a ...]
<span class="code-attr-method">map</span>{* 2} [1 2 3]  <span class="code-attr-comment-block">; [2 4 6]
</span>= f <span class="code-attr-method">map</span>{* 2}
f [1 2 3]         <span class="code-attr-comment-block">; [2 4 6]
</span>
= (+) {== 1 <span class="code-attr-method">len</span>(...) {+ $$0 $0} (__builtin__.+ _0 _1)}
= add {+ ...}
<span class="code-attr-method">add</span>(9)   <span class="code-attr-comment-block">; #(+ 9 $0)
</span><span class="code-attr-method">add</span>(9) 1 <span class="code-attr-comment-block">; 10
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 部分適用
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 59%  #影響度 200%
</span><span class="code-attr-comment-block">;; #関連仕様 [#遅延評価]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 部分適用を基本機能として組み込む
</span><span class="code-attr-comment-block">;; 全ての式をカリー化の対象にする
</span><span class="code-attr-comment-block">;;
</span>= f ~~ + _ _
= g (f 1)  <span class="code-attr-comment-block">; {[a] |b| f a b} 1
</span>(g 2)      <span class="code-attr-comment-block">; 3
</span>(f 1)(2)   <span class="code-attr-comment-block">; 3
</span>
= lt (&lt; 1)
lt 2       <span class="code-attr-comment-block">; true
</span>
<span class="code-attr-comment-block">;; 部分適用式との比較
</span>f&lt;1&gt; 2
<span class="code-attr-method">lt</span>{&lt; 1} 2

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 代理関数呼び出し
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #拡張機能  #重要度 90%  #影響度 25%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 1. 関数呼び出し時
</span><span class="code-attr-comment-block">;;    第一オペランドがオペレータと同名のメンバ関数を持つ場合はそちら呼び出す
</span><span class="code-attr-comment-block">;; 2. メソッド呼び出し時
</span><span class="code-attr-comment-block">;;    メンバ関数が存在しない場合は同名のグローバル関数を呼び出す
</span><span class="code-attr-comment-block">;; ※ 両探索は再帰的に行われないものとする
</span><span class="code-attr-comment-block">;;
</span>len <span class="code-attr-string">"a"</span>   <span class="code-attr-comment-block">; "a".len()
</span>1.+ 2     <span class="code-attr-comment-block">; (+ 1 2)
</span>
<span class="code-attr-comment-block">;; 問題点
</span><span class="code-attr-comment-block">;; プライベートメソッドを誤って呼び出してしまう
</span><span class="code-attr-comment-block">;; 対応案
</span><span class="code-attr-comment-block">;; アンダースコアで暗黙的な非公開メソッドを明示する
</span>exte <span class="code-attr-object">String</span>
  fn _privateFn () <span class="code-attr-type">nil</span>
  fn publicFn   () <span class="code-attr-type">nil</span>
  fn _print     () <span class="code-attr-string">"A"</span>
  fn log        () % <span class="code-attr-string">"String: \"%s\""</span> __raw__

privateFn <span class="code-attr-string">""</span>  <span class="code-attr-comment-block">;; error
</span>publicFn  <span class="code-attr-string">""</span>  <span class="code-attr-comment-block">;; ok
</span><span class="code-attr-keyword">print</span> <span class="code-attr-string">""</span>      <span class="code-attr-comment-block">; &lt;String: 0x12345678&gt;
</span>_print <span class="code-attr-string">""</span>     <span class="code-attr-comment-block">; "A"
</span>log    <span class="code-attr-string">""</span>     <span class="code-attr-comment-block">; &lt;String: ""&gt;
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; プロパティ呼び出し
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 60%  #影響度 100%
</span><span class="code-attr-comment-block">;; #関連仕様 [#遅延評価 #式展開の原則]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; プロパティを実現するために関数呼び出しの仕組みを変更する案
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 案１ -- 関数呼び出しをデフォルトにする
</span><span class="code-attr-string">"ab"</span>.len   <span class="code-attr-comment-block">; 2
</span>#<span class="code-attr-string">"ab"</span>.len  <span class="code-attr-comment-block">; func String::len
</span><span class="code-attr-string">"ab"</span>.len#  <span class="code-attr-comment-block">; 案２
</span><span class="code-attr-string">"ab"</span>.len&amp;  <span class="code-attr-comment-block">; 案３
</span><span class="code-attr-string">"ab"</span>.&amp;len  <span class="code-attr-comment-block">; 案４（前置のほうが明確）
</span><span class="code-attr-string">"ab"</span>::<span class="code-attr-object">len</span>  <span class="code-attr-comment-block">; 案５（静的メンバ採用時注意 -&gt; Int::MAX vs 9::MAX）
</span>
<span class="code-attr-comment-block">;; 案２ -- 後置"."を関数呼び出しのトリガーにする
</span><span class="code-attr-type">self</span>.copy.append <span class="code-attr-string">"a"</span> <span class="code-attr-comment-block">; self().copy().append("a")
</span>  
<span class="code-attr-comment-block">;; 案３ -- 遅延評価の仕様に例外を設ける
</span><span class="code-attr-keyword">func</span> test (#f)
  <span class="code-attr-comment-block">;; before
</span>  f  <span class="code-attr-comment-block">; func String::len
</span>  <span class="code-attr-comment-block">;; after
</span>  f  <span class="code-attr-comment-block">; 2
</span>test <span class="code-attr-string">"ab"</span>.len   <span class="code-attr-comment-block">; 2
</span>test #<span class="code-attr-string">"ab"</span>.len  <span class="code-attr-comment-block">; func String::len
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 式展開の原則
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #拡張機能
</span><span class="code-attr-comment-block">;; #重要度 75%  #影響度 200%
</span><span class="code-attr-comment-block">;; #前提仕様 [#遅延評価]
</span><span class="code-attr-comment-block">;; #関連仕様 [#プロパティ呼び出し]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 遅延評価の仕様を拡張
</span><span class="code-attr-comment-block">;; 式の文脈に応じて式の展開と譲渡を分ける
</span><span class="code-attr-comment-block">;;   - [#プロパティ呼び出し 案１]の実現に必要
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 1. 式がオペレータとして評価できる場合は展開を行う
</span><span class="code-attr-comment-block">;; 2. 式がオペランドとして評価される場合は展開を行わない
</span><span class="code-attr-comment-block">;; 3. オペレータが遅延評価式の場合は展開を行う
</span><span class="code-attr-comment-block">;; 4. メンバアクセスについては常に展開を行う
</span><span class="code-attr-comment-block">;; 5. アンダースコアで始まるシンボルの場合は展開を行う
</span><span class="code-attr-comment-block">;;
</span>= say ~~ <span class="code-attr-string">"hello"</span>
say             <span class="code-attr-comment-block">; "hello"
</span>#say            <span class="code-attr-comment-block">; ~~ "hello"
</span>{#_0} say       <span class="code-attr-comment-block">; ~~ "hello"
</span>{#_0} (say 1)   <span class="code-attr-comment-block">; "hello"
</span>say.len         <span class="code-attr-comment-block">; 5
</span><span class="code-attr-string">"a"</span>.len         <span class="code-attr-comment-block">; 1
</span>{#_0}  <span class="code-attr-string">"a"</span>.len  <span class="code-attr-comment-block">; 1
</span>{#_0} #<span class="code-attr-string">"a"</span>.len  <span class="code-attr-comment-block">; func String::len
</span>
<span class="code-attr-comment-block">;; [#前置呼び出し昇格]への影響を考慮する必要がある
</span>^(a) <span class="code-attr-keyword">print</span> a  <span class="code-attr-comment-block">; (fn (a) print a) ; (## fn (a) pritn a)
</span>
<span class="code-attr-comment-block">;; break文の実現
</span><span class="code-attr-keyword">func</span> <span class="code-attr-keyword">while</span> (#cond #stmt)
  = i     0
  = stop  0
  = <span class="code-attr-keyword">break</span> ~~ :stop 1 :$local[<span class="code-attr-string">"return"</span>] $0
  <span class="code-attr-keyword">if</span> &amp;&amp; cond
        !stop
    stmt i--
<span class="code-attr-keyword">while</span> <span class="code-attr-type">true</span>
  <span class="code-attr-keyword">if</span> &gt; 9 $0
    <span class="code-attr-keyword">print</span> $0
    <span class="code-attr-keyword">break</span>

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 引数リスト
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #重要度 75%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  ラムダ宣言時の仮引数の明示／省略を可能とする
</span><span class="code-attr-comment-block">;;  第一引数を仮引数リストとして解釈するラムダ式（`~ (a) a`）と
</span><span class="code-attr-comment-block">;;  そうでないラムダ式（`~~ _0`）、その両者の区別をなくす
</span><span class="code-attr-comment-block">;;  基本仕様:
</span><span class="code-attr-comment-block">;;    引数リストは配列リテラルと同等の記法で表現する
</span><span class="code-attr-comment-block">;;  拡張仕様:
</span><span class="code-attr-comment-block">;;    引数リストは`|`で囲われたリストの形での表現も可能
</span><span class="code-attr-comment-block">;;      `{}`内では開始`|`の省略が可能
</span><span class="code-attr-comment-block">;;    引数リストは`|`で囲われたリストが用いられた場合、`{}`の省略が可能
</span><span class="code-attr-comment-block">;;
</span>= add ~~ [a b] (+ a b)
= sub ~~ (- _0 _1)
= mul ~ (* $0 $1)
= not fn !! _
{[a] <span class="code-attr-keyword">print</span> a} 1 <span class="code-attr-comment-block">; "1"
</span>{<span class="code-attr-keyword">print</span> _} 2     <span class="code-attr-comment-block">; "2"
</span>
{a| <span class="code-attr-keyword">print</span> a} 1  <span class="code-attr-comment-block">; "1"
</span><span class="code-attr-method">flip</span>(apply) 1 |a| <span class="code-attr-keyword">print</span> a <span class="code-attr-comment-block">; "1"
</span>
<span class="code-attr-comment-block">;; 影響
</span>{<span class="code-attr-keyword">print</span>| 0 1}()  <span class="code-attr-comment-block">; (0 1)
</span>{<span class="code-attr-keyword">print</span> | 0 1}() <span class="code-attr-comment-block">; "1"
</span>+= add {last          | last              }
+= add {first ...rest | + first (...rest) }
add 1 2 3 <span class="code-attr-comment-block">; 6
</span><span class="code-attr-comment-block">; 可読性の低下
</span><span class="code-attr-method">f</span>(g v| g 1 v)  <span class="code-attr-comment-block">; `g v`は関数呼び出し式に見えてしまう
</span><span class="code-attr-method">f</span>(g, v| g 1 v) <span class="code-attr-comment-block">; 若干明確
</span><span class="code-attr-method">f</span>(|g v| g 1 v) <span class="code-attr-comment-block">; より明確（ラムダ式の開始位置が明確になる）
</span>
<span class="code-attr-comment-block">;; 影響
</span><span class="code-attr-comment-block">;;   コア機能に影響
</span><span class="code-attr-comment-block">;;   ラムダ宣言関数`fn`, `~~`の内部で引数リスト`[]`の判定が必要になる
</span><span class="code-attr-comment-block">;;   配列リテラルとリストの内部表現を区別する必要がある
</span><span class="code-attr-comment-block">; before
</span>typeof [1 2]  <span class="code-attr-comment-block">; List
</span>typeof (1 2)  <span class="code-attr-comment-block">; List
</span><span class="code-attr-comment-block">; after
</span>typeof [1 2]  <span class="code-attr-comment-block">; Array
</span>typeof (1 2)  <span class="code-attr-comment-block">; List
</span>
<span class="code-attr-comment-block">;; 対応
</span><span class="code-attr-comment-block">;;   前置引数リスト
</span><span class="code-attr-comment-block">;;   配列リテラルとの区別が可能になる
</span><span class="code-attr-comment-block">;;   ただし紛らわしい
</span><span class="code-attr-comment-block">;; #重要度 25%
</span><span class="code-attr-comment-block">;;
</span>[a b]{+ a b}
(a b){+ a b}

sort (a b) {&lt; a b} <span class="code-attr-comment-block">; sort (a b), {&lt; a b}
</span>sort [a b] {&lt; a b} <span class="code-attr-comment-block">; sort ([a b] {&lt; a b})
</span>sort (a b){&lt; a b} <span class="code-attr-comment-block">;  sort ((a b) {&lt; a b})
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 引数リストの記法に意味を持たせる
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #関連 [#関数オーバーロード]
</span><span class="code-attr-comment-block">;;
</span>+= sum {[a b] <span class="code-attr-string">"a"</span>}
+= sum {(a b) <span class="code-attr-string">"b"</span>}
sum [1 2] <span class="code-attr-comment-block">; "a"
</span>sum 1 2   <span class="code-attr-comment-block">; "b"
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 遅延評価の拡張
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 変数宣言時にも遅延評価の仕組みを利用可能にする
</span><span class="code-attr-comment-block">;;
</span>#= f (+ 1 2)
#f <span class="code-attr-comment-block">; (+ 1 2)
</span>&amp;f <span class="code-attr-comment-block">; (+ 1 2)
</span>f  <span class="code-attr-comment-block">; 3
</span>*f <span class="code-attr-comment-block">; 3 
</span>=# f (+ 1 2) <span class="code-attr-comment-block">; 案２（`=#`演算子側で遅延束縛~~参照バインド~~）
</span># f  (+ 1 2) <span class="code-attr-comment-block">; 案３（`#`演算子を定義）
</span>= f #(+ 1 2) <span class="code-attr-comment-block">; 案４（前置`#`でラップ）
</span>= f &amp;(+ 1 2) <span class="code-attr-comment-block">; 案５
</span>=&amp; f (+ 1 2) <span class="code-attr-comment-block">; 案６
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 連結演算子
</span><span class="code-attr-comment-block">;;
</span>1 . [2 3]   <span class="code-attr-comment-block">; [1 2 3]
</span>. 1 [2 3]   <span class="code-attr-comment-block">; 要検討 #TODO (.f class{__call__: assert(_ "f")})
</span>            <span class="code-attr-comment-block">;             (.  class{__call__: assert(_ "" )})
</span>[1] . [2 3] <span class="code-attr-comment-block">; [[1] 2 3]
</span>+ [1] [2 3] <span class="code-attr-comment-block">; [1 2 3]
</span>{|first ...rest| first.rest}(1 2) <span class="code-attr-comment-block">; [1 2]
</span>{|v.w| w}(1 2 3) <span class="code-attr-comment-block">; ...(2 3)
</span>{[v.w] w}(1 2 3) <span class="code-attr-comment-block">; [2 3]
</span>
+= sum {0}
+= sum {[car.cdr] + car (sum cdr)}
sum [1 2 3] <span class="code-attr-comment-block">; 6
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 演算子の結合規則
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; 演算子を優先的に解釈する
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-keyword">print</span> + 1 2  <span class="code-attr-comment-block">; print (+ 1 2)
</span>+ 1 + 2 3    <span class="code-attr-comment-block">; (+ 1 (+ 2 3))
</span>+ 1 (+) 2 3  <span class="code-attr-comment-block">; (+ 1 + 2 3)
</span>
<span class="code-attr-comment-block">;; 二項演算子は第二引数までを処理する
</span><span class="code-attr-comment-block">;;
</span>+ 1 2 3      <span class="code-attr-comment-block">; (+ 1 2) 3
</span>+ + 1 2 3    <span class="code-attr-comment-block">; (+ (+ 1 2) 3)
</span>+ + 1 2 3 4  <span class="code-attr-comment-block">; (+ (+ 1 2) 3) 4
</span><span class="code-attr-keyword">if</span> == 1 2 + 1 2 <span class="code-attr-comment-block">; (if (== 1 2) (+ 1 2))
</span><span class="code-attr-keyword">if</span> == 1 + 2 3 4 <span class="code-attr-comment-block">; (if (== 1 (+ 2 3) 4))
</span>
<span class="code-attr-comment-block">;; 単行演算子は第１引数までを処理する
</span><span class="code-attr-comment-block">;;
</span>! 1  <span class="code-attr-comment-block">; false
</span>~ 0  <span class="code-attr-comment-block">; -1
</span><span class="code-attr-comment-block">;; 問題
</span>- 1 2  <span class="code-attr-comment-block">; (- 1) (2)
</span>~ [a] <span class="code-attr-keyword">echo</span> a  <span class="code-attr-comment-block">; (~ [a]) (echo a)
</span><span class="code-attr-comment-block">;; 代案 --&gt; [#前置呼び出し]
</span><span class="code-attr-comment-block">;; 代案 --&gt; [#TODO 優先順位の既定] #重要度 0%
</span><span class="code-attr-comment-block">;; 代案 --&gt; [#二項演算優先の原則] --&gt; [#可変長式]
</span>- - 2 1 <span class="code-attr-comment-block">; -1
</span>! - 2 2 <span class="code-attr-comment-block">; true
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 演算子の結合規則（拡張）
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #関連 [#ブロック内包式の結合規則]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 二項演算の最終オペランドに続く要素が他のオペレータのオペランドになりえない場合
</span><span class="code-attr-comment-block">;; 最終オペランドをオペレータとみなし、続く要素をそのオペレータのオペランドとみなす
</span><span class="code-attr-comment-block">;;
</span>== <span class="code-attr-string">"String"</span> typeof <span class="code-attr-string">""</span>  <span class="code-attr-comment-block">; (== "String" (typeof ""))
</span><span class="code-attr-comment-block">;; #TODO
</span><span class="code-attr-keyword">if</span> == <span class="code-attr-string">"String"</span> typeof <span class="code-attr-string">""</span> yes  <span class="code-attr-comment-block">;; !!!: (typeof "" yes)
</span><span class="code-attr-keyword">if</span> == <span class="code-attr-string">"String"</span> typeof <span class="code-attr-string">""</span>
  yes
<span class="code-attr-keyword">if</span> == a b yes  <span class="code-attr-comment-block">; if (== a b) yes   ;; 演算子優先
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 可変長式
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 二項演算優先の原則に例外を設ける
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #TODO 整理必要
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ※ 二項演算優先の原則自体の廃止を検討  #2017-01-08
</span><span class="code-attr-comment-block">;;  - 演算子のみを特別に扱うのは一貫性に欠けるのではないか
</span><span class="code-attr-comment-block">;;    - 関数と演算子は等価に扱うべきか
</span><span class="code-attr-comment-block">;;    - 一貫性と多様性のどちらを重視するべきか
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; 1. 演算子に続く要素が値として評価できる場合は
</span><span class="code-attr-comment-block">;;    たとえそれが三項目以降の要素であっても
</span><span class="code-attr-comment-block">;;    演算子に対応する被演算子と見なすことができる
</span>+ 1 2 3        <span class="code-attr-comment-block">; (+ 1 2 3)
</span>+ 1 2 - 3      <span class="code-attr-comment-block">; (+ 1 2) (- 3)
</span><span class="code-attr-method">print</span>(+ 1 2 3) <span class="code-attr-comment-block">; print (+ 1 2 3)
</span>
<span class="code-attr-comment-block">;; 2. 続く要素に演算子が現れた場合はその後に続く要素全てを
</span><span class="code-attr-comment-block">;;    その演算子の被演算子とみなすことができる
</span>+ 1 + 2 3 4     <span class="code-attr-comment-block">; + 1 (+ 2 3 4)
</span>= v + 1 2 3     <span class="code-attr-comment-block">; = v (+ 1 2 3)
</span>= v + 1 + 2 3 4 <span class="code-attr-comment-block">; = v (+ 1 (+ 2 3 4))
</span>= add  ~ (a b) + a b <span class="code-attr-comment-block">;; = add (~ (a b) (+ a b))
</span>= add fn (a b) + a b <span class="code-attr-comment-block">;; ???: 予約語については要検討
</span>
<span class="code-attr-comment-block">;; 3. オペレータが連続する場合は内側のオペレータを二項演算として処理する
</span>+ + 1 2 3 4 <span class="code-attr-comment-block">; + (+ 1 2) 3 4
</span><span class="code-attr-keyword">if</span> != <span class="code-attr-type">nil</span> obj <span class="code-attr-keyword">print</span> obj  <span class="code-attr-comment-block">; if (!= nil obj) print obj
</span>
<span class="code-attr-comment-block">;; 4. ユーザ定義関数については(1.)の仕様のみが適用される
</span>add add 1 2 3 <span class="code-attr-comment-block">; (add (add) 1 2 3)
</span><span class="code-attr-comment-block">; ※ ifを文ではなく関数と仮定した場合
</span><span class="code-attr-keyword">if</span> eq 1 1 yes no   <span class="code-attr-comment-block">; (if eq 1 1 yes no)
</span><span class="code-attr-keyword">if</span> (eq 1 1) yes no <span class="code-attr-comment-block">; (if (eq 1 1) yes no)
</span>  
<span class="code-attr-comment-block">;; 可変長式は可変長引数で処理する
</span><span class="code-attr-keyword">func</span> add (...) (+ ...)
add 1 2    <span class="code-attr-comment-block">; 3
</span>add 1 2 3  <span class="code-attr-comment-block">; 6
</span>
<span class="code-attr-comment-block">;; switch文の実装
</span><span class="code-attr-keyword">func</span> <span class="code-attr-keyword">switch</span> (val ...cases)
    = [i c] [0 <span class="code-attr-method">size</span>(cases)] <span class="code-attr-comment-block">; = [:i 0 :c size(cases)] ; :i 0 :c size(cases)
</span>    <span class="code-attr-keyword">while</span> [(&lt; i c) ++i]
      <span class="code-attr-keyword">if</span> == val cases[i][0]
        <span class="code-attr-keyword">return</span> cases[i][1]
<span class="code-attr-keyword">switch</span> argc
  1 <span class="code-attr-keyword">print</span> <span class="code-attr-string">"1"</span>
  2 <span class="code-attr-keyword">print</span> <span class="code-attr-string">"2"</span>

<span class="code-attr-comment-block">;; ヨーダ記法との相性
</span>== <span class="code-attr-string">"abc"</span> + a b c
== (+ a b c) <span class="code-attr-string">"abc"</span> <span class="code-attr-comment-block">; ヨーダ記法未使用時
</span>
<span class="code-attr-comment-block">;; 備考  #2017-01-08
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 以前、以下のような解釈を検討していた
</span>== <span class="code-attr-string">"A"</span> upcase <span class="code-attr-string">"a"</span>  <span class="code-attr-comment-block">; == "A" (upcase "a")
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; オペランドの結合規則
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;     #コア機能  #拡張機能  #重要度 100%  #影響度 100%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   オペランドが複数指定された場合の結合規則
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; カンマ演算子の結合規則
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;     #拡張機能  #重要度 75%  #影響度 100%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   カンマの記述箇所によって要素式の結合規則が変化する
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; コロン演算子の結合規則
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;     #拡張機能  #重要度 75%  #影響度 50%
</span><span class="code-attr-comment-block">;;     #関連 [#段落結合]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   コロンが後置された場合（`f a: b c`）
</span><span class="code-attr-comment-block">;;     以降の式を、外延する単一の要素式とする（`(f a (b c))`）
</span><span class="code-attr-comment-block">;;   コロンが前後空白有りで後置された場合（`f a : b c`）
</span><span class="code-attr-comment-block">;;     以降の要素式の並びを、外延する要素式の並びとする（`(f a b c)`）
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; 案０ -- 左畳み込みを基準とする
</span>a b c d  <span class="code-attr-comment-block">; (((a b) c) d) ;; #TODO：部分適用のデフォルト化
</span>a b c, d <span class="code-attr-comment-block">; ((a (b c)) d)
</span>
<span class="code-attr-comment-block">;; 案１ -- オペレータとオペランドの関係性を基準とする
</span>a b c d  <span class="code-attr-comment-block">; (a b c d)
</span>a b c, d <span class="code-attr-comment-block">; (a (b c) d) ;; （オペレータ重視）
</span>
<span class="code-attr-keyword">echo</span> add 1 2    <span class="code-attr-comment-block">; echo (add) 1 2)
</span><span class="code-attr-keyword">echo</span> add 1, 2   <span class="code-attr-comment-block">; echo (add 1) 2
</span>
<span class="code-attr-keyword">if</span> eq 1 2, yes no <span class="code-attr-comment-block">; if (eq 1 2) yes no
</span><span class="code-attr-keyword">echo</span>, add 1 2    <span class="code-attr-comment-block">; echo (add 1 2)
</span><span class="code-attr-keyword">echo</span>:add 1 2     <span class="code-attr-comment-block">; echo (add 1 2)
</span>
<span class="code-attr-comment-block">;; 案２ -- 右畳み込みを基準とする
</span>a b c d  <span class="code-attr-comment-block">; (a (b (c d)))
</span>a b c, d <span class="code-attr-comment-block">; (a (b c d))   ;; （オペランド重視）
</span>
<span class="code-attr-keyword">echo</span> add 1 2    <span class="code-attr-comment-block">; echo (add (1 2))
</span><span class="code-attr-keyword">echo</span> add 1, 2   <span class="code-attr-comment-block">; echo (add 1 2)
</span><span class="code-attr-keyword">echo</span>, add 1, 2  <span class="code-attr-comment-block">; echo (add 1) 2
</span><span class="code-attr-keyword">echo</span> add 1, 2 3 <span class="code-attr-comment-block">; echo (add 1 (2 3))
</span>
<span class="code-attr-keyword">echo</span> add 1, minus 2 <span class="code-attr-comment-block">; echo (add 1 (minus 2))
</span><span class="code-attr-keyword">echo</span> eq add 1, 2 <span class="code-attr-comment-block">; echo (eq) (add 1 2)
</span>                 <span class="code-attr-comment-block">; echo (eq (add 1 2))
</span>
<span class="code-attr-keyword">echo</span> add 1, 2,, 3   <span class="code-attr-comment-block">; echo (add 1 2) 3
</span><span class="code-attr-keyword">echo</span> add 1, 2 : 3   <span class="code-attr-comment-block">; echo (add 1 2) 3
</span>
<span class="code-attr-keyword">if</span> eq 1, <span class="code-attr-label">2</span>: <span class="code-attr-keyword">print</span> yes <span class="code-attr-comment-block">; if (eq 1 2) (print yes)
</span><span class="code-attr-keyword">if</span> eq 1, 2 : yes no   <span class="code-attr-comment-block">; if (eq 1 2) yes no
</span><span class="code-attr-keyword">if</span> eq 1 2 : yes no    <span class="code-attr-comment-block">; if (eq 1 2) yes no ;; 関連：[#演算子の結合規則（拡張）]
</span>
<span class="code-attr-comment-block">; 検証
</span><span class="code-attr-keyword">echo</span> add 1, 2,, 3   <span class="code-attr-comment-block">; echo (add 1 2) 3
</span><span class="code-attr-keyword">echo</span> add 1, 2 : 3   <span class="code-attr-comment-block">; echo (add 1 2) 3
</span><span class="code-attr-keyword">echo</span> (add 1 2) 3    <span class="code-attr-comment-block">; echo (add 1 2) 3
</span><span class="code-attr-keyword">if</span>, eq 0 <span class="code-attr-string">""</span>, yes, no
<span class="code-attr-keyword">if</span> eq 3 add 1, 2,,, yes no
<span class="code-attr-keyword">if</span> eq 3 add 1, 2 :: yes no

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; アンダースコア命名規則
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 75%  #影響度 50%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; アンダースコアで始まる変数は暗黙的にthisのメンバを指すものとする
</span><span class="code-attr-comment-block">;;
</span>= add ~~ + _0 _1 <span class="code-attr-comment-block">; = add (~~ (+ this["0"] this["1"]))
</span>{<span class="code-attr-keyword">echo</span> _} 2 <span class="code-attr-comment-block">; 2?  this[""]?
</span><span class="code-attr-keyword">class</span> X
  = v 1
  <span class="code-attr-keyword">func</span> f () _v
= x X
x.f   <span class="code-attr-comment-block">; 1
</span>= (#x.f)._v 2
x.f   <span class="code-attr-comment-block">; 2
</span>x.v   <span class="code-attr-comment-block">; 1
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; アンダースコア１文字変数
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #関連 [#アンダースコア命名規則]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; `_`出現時の暗黙の関数呼び出しを実現する仕様が必要（関連: [#式展開の原則]）
</span><span class="code-attr-comment-block">;; 以下の記法の実現を前提とする
</span><span class="code-attr-comment-block">;;
</span>
[1 2 3].sort {&gt; _ _} <span class="code-attr-comment-block">; [3 2 1]
</span>
= add ~~ + _ _ <span class="code-attr-comment-block">;; `+ _0 _1`と同等処理
</span>add 1 2  <span class="code-attr-comment-block">; 3
</span>
= isdigit <span class="code-attr-object">IsDigit</span> {
  &amp;&amp;  &gt;= _ <span class="code-attr-character">'0'</span>  &lt;= _ <span class="code-attr-character">'9'</span> <span class="code-attr-comment-block">;; `_0 _0`と同等処理
</span>}

<span class="code-attr-keyword">class</span> <span class="code-attr-object">IsDigit</span>
  fn init [:_f <span class="code-attr-label">f</span>:<span class="code-attr-object">Function</span>]  :_f.__static__ <span class="code-attr-type">self</span>
  fn <span class="code-attr-keyword">operator</span>() [:_arg <span class="code-attr-label">arg</span>:<span class="code-attr-object">Character</span>]  _f arg
  fn _ [] _arg

<span class="code-attr-keyword">class</span> <span class="code-attr-object">Add</span>
  fn init [<span class="code-attr-label">f</span>:<span class="code-attr-object">Function</span>] = _f f
  fn <span class="code-attr-keyword">operator</span>() [...<span class="code-attr-label">args</span>:<span class="code-attr-object">Any</span>]
    = _args <span class="code-attr-method">Array</span>(...args)
    = _f.__static__ <span class="code-attr-type">self</span>
    _f arg
  fn _ [] _args.pop
= add <span class="code-attr-object">Add</span> {+ _ _}

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ドルマーク一文字オブジェクト
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; `$`で始まる記法を特別に解釈する
</span><span class="code-attr-comment-block">;;
</span>$     <span class="code-attr-comment-block">; 第一仮引数
</span>$0    <span class="code-attr-comment-block">; 第一仮引数
</span>$.0   <span class="code-attr-comment-block">; メンバアクセス
</span>$::<span class="code-attr-object">v</span>  <span class="code-attr-comment-block">; 未規定
</span>$<span class="code-attr-type">this</span> <span class="code-attr-comment-block">; 自身の関数
</span>$()   <span class="code-attr-comment-block">; 関数呼び出し
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 比較演算子の拡張
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #拡張機能  #重要度 0%  #影響度 100%
</span><span class="code-attr-comment-block">;; #代替案 [#代入演算子の変更]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 式中の代入演算子`=`を文脈に応じて比較演算子`==`として解釈させる
</span><span class="code-attr-comment-block">;;
</span>
= a <span class="code-attr-string">"foo"</span> <span class="code-attr-comment-block">;; 案１
</span>=b <span class="code-attr-string">"bar"</span>  <span class="code-attr-comment-block">;; 案２
</span><span class="code-attr-keyword">if</span> (= a b) <span class="code-attr-keyword">print</span> a  <span class="code-attr-comment-block">; if (== a b) print a
</span>
<span class="code-attr-comment-block">;; 影響
</span><span class="code-attr-keyword">func</span> lazyView () ?? _view = _view (<span class="code-attr-object">View</span> <span class="code-attr-type">new</span>) <span class="code-attr-comment-block">; javascript: return _view || (_view = new View)
</span><span class="code-attr-keyword">while</span> = next next.next  <span class="code-attr-keyword">print</span> next.v

<span class="code-attr-comment-block">;; 対応案
</span><span class="code-attr-keyword">return</span> =_view (<span class="code-attr-object">View</span> <span class="code-attr-type">new</span>)
<span class="code-attr-keyword">return</span> : _view (<span class="code-attr-object">View</span> <span class="code-attr-type">new</span>)
<span class="code-attr-keyword">return</span> :: _view (<span class="code-attr-object">View</span> <span class="code-attr-type">new</span>)
<span class="code-attr-keyword">return</span> == _view (<span class="code-attr-object">View</span> <span class="code-attr-type">new</span>)

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 演算子の用途変更
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #拡張機能  #影響度 100%
</span><span class="code-attr-comment-block">;; #重要度 70% #2017-01-06
</span><span class="code-attr-comment-block">;; #重要度 50% #2016-12-28
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 文字数の少ない演算子を利用頻度の高い演算子へ優先的に割り当てる
</span><span class="code-attr-comment-block">;;  - 前置記法の性質上、文字数の広い記号を用いることによる
</span><span class="code-attr-comment-block">;;    視認性や可読性の向上はさほど期待できない
</span><span class="code-attr-comment-block">;;     * 中置記法の場合はオペランド間の区切りを
</span><span class="code-attr-comment-block">;;       より明確にできるという意味では実に効果的であった
</span><span class="code-attr-comment-block">;;  - 前置記法の場合は文字揃えを効果的に用いることで、
</span><span class="code-attr-comment-block">;;    より視認性・可読性の高いコードを書くことができる
</span><span class="code-attr-comment-block">;;  - 一文字幅の演算子はきわめて尊い存在であり
</span><span class="code-attr-comment-block">;;    また２文字幅インデントとの相性も良いことから
</span><span class="code-attr-comment-block">;;    頻繁に使われる演算に対して優先的に割り当てたい
</span><span class="code-attr-comment-block">;;  - コア機能として取り込むか、または
</span><span class="code-attr-comment-block">;;    演算子オーバーロードでユーザ定義可能にするかは検討中
</span><span class="code-attr-comment-block">;;      `func (=) #__builtin__.operators["EQ"]`
</span><span class="code-attr-comment-block">;;      `func (!) #__builtin__.operators["NOT_EQ"]`
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; | `==` | 束縛演算子 -- 案１
</span><span class="code-attr-comment-block">;; | `:`  | 束縛演算子 -- 案２
</span><span class="code-attr-comment-block">;; | `=`  | 比較演算子　（EQ）
</span><span class="code-attr-comment-block">;; | `!`  | 比較演算子　（NOT EQ）
</span><span class="code-attr-comment-block">;; | `!=` | 論理演算子　（NOT）-- 案１
</span><span class="code-attr-comment-block">;; | `!!` | 論理演算子　（NOT）-- 案２
</span><span class="code-attr-comment-block">;; | `~=` | ビット演算子（bitwise NOT）-- 案１
</span><span class="code-attr-comment-block">;; | `!~` | ビット演算子（bitwise NOT）-- 案２
</span><span class="code-attr-comment-block">;; | `&amp;`  | 論理演算子　（AND）
</span><span class="code-attr-comment-block">;; | `|`  | 論理演算子　（OR）
</span><span class="code-attr-comment-block">;; | `&amp;&amp;` | ビット演算子（bitwise AND）-- 案１
</span><span class="code-attr-comment-block">;; | `||` | ビット演算子（bitwise OR） -- 案１
</span><span class="code-attr-comment-block">;; | `&amp;^` | ビット演算子（bitwise AND）-- 案２
</span><span class="code-attr-comment-block">;; | `|^` | ビット演算子（bitwise OR） -- 案２
</span><span class="code-attr-comment-block">;; | `&amp;~` | ビット演算子（bitwise AND）-- 案３
</span><span class="code-attr-comment-block">;; | `|~` | ビット演算子（bitwise OR） -- 案３
</span><span class="code-attr-comment-block">;; | `^^` | 排他的論理和（XOR）
</span><span class="code-attr-comment-block">;; | `^`  | ラムダ宣言式 -- 未定
</span><span class="code-attr-comment-block">;; | `?`  | 条件演算子
</span><span class="code-attr-comment-block">;; | `??` | 未定 - 案: (?? 0 1)   clang: (0 ?: 1)    == 1
</span><span class="code-attr-comment-block">;; | `?:` | 未定 - 案: (?; 0 1 0) clang: (0 ? 1 : 0) == 1
</span><span class="code-attr-comment-block">;;
</span>= 1 2    <span class="code-attr-comment-block">; javascript: 1 == 2
</span>! 1 2    <span class="code-attr-comment-block">; javascript: 1 != 2
</span>!!<span class="code-attr-type">true</span>   <span class="code-attr-comment-block">; javascript: !true      ; 案１
</span>!<span class="code-attr-type">true</span>    <span class="code-attr-comment-block">; javascript: !true      ; 案２
</span>! <span class="code-attr-type">true</span> 2 <span class="code-attr-comment-block">; javascript: true != 2  ; 案２
</span>
== s <span class="code-attr-string">"foo"</span>
<span class="code-attr-keyword">if</span> (= s <span class="code-attr-string">"foo"</span>) <span class="code-attr-keyword">print</span> s <span class="code-attr-comment-block">; "foo"
</span>
<span class="code-attr-keyword">if</span> &amp; ! s <span class="code-attr-type">null</span>
   | = s <span class="code-attr-string">"UTF8"</span>  <span class="code-attr-comment-block">;; [#ブロック内包式の結合規則#ブロック内包式の演算子結合]
</span>     = s <span class="code-attr-string">"SJIS"</span>
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"yes"</span>
<span class="code-attr-comment-block">; if (s != null   &amp;&amp;
</span><span class="code-attr-comment-block">;     s == "UTF8" ||
</span><span class="code-attr-comment-block">;     s == "SJIS")
</span><span class="code-attr-comment-block">;   print("yes")
</span>
cond <span class="code-attr-label">with</span>:bar
  (= <span class="code-attr-string">"String"</span> typeof _) cond <span class="code-attr-label">with</span>:_
      (= <span class="code-attr-string">"bar"</span> _) <span class="code-attr-keyword">print</span> <span class="code-attr-string">"Bar"</span>
      (! <span class="code-attr-string">"foo"</span> _) <span class="code-attr-keyword">print</span> <span class="code-attr-string">"oof"</span>
  (= <span class="code-attr-string">"Number"</span> typeof _) cond <span class="code-attr-label">with</span>:_
      (&amp; 0xFF00 _) <span class="code-attr-keyword">print</span> ^^ _
      (| 0x0F0F _) <span class="code-attr-keyword">print</span> !! _

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 代入演算子の変更
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #拡張機能  #重要度 75%  #影響度 100%
</span><span class="code-attr-comment-block">;; #関連仕様 [#演算子の用途変更]
</span><span class="code-attr-comment-block">;;          [#遅延評価]
</span><span class="code-attr-comment-block">;;          [#遅延評価の拡張]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; `=`（代入演算子／変数宣言式）を廃止
</span><span class="code-attr-comment-block">;; `=`を比較演算子として利用
</span><span class="code-attr-comment-block">;; `:`を代入演算子として利用
</span><span class="code-attr-comment-block">;; Map型の宣言式と変数宣言式を統合する
</span><span class="code-attr-comment-block">;;
</span>:a <span class="code-attr-string">"foo"</span>    <span class="code-attr-comment-block">; var a = "foo";
</span><span class="code-attr-label">a</span>: <span class="code-attr-string">"foo"</span>
: a <span class="code-attr-string">"foo"</span>
:b :a <span class="code-attr-string">"foo"</span> <span class="code-attr-comment-block">; var b = {a: "foo"};  ???
</span>:a 1 :b 2   <span class="code-attr-comment-block">; var a = 1; var b = 2;
</span>[:a 1 :b 2] <span class="code-attr-comment-block">; {a: 1, b: 2}
</span>{:a 1 :b 2} <span class="code-attr-comment-block">; fn () {:a 1 :b 2}
</span>[:a 1 :b 2] <span class="code-attr-comment-block">; {this.a = 1; this.b = 2;}.a == 1
</span>:dic {:a 1 :b 2}() <span class="code-attr-comment-block">;; #TODO [#束縛演算子の戻り値]（案: thisを返す）
</span>dic.a       <span class="code-attr-comment-block">; 1
</span>:dic {:a 1 :b 2}
dic.a       <span class="code-attr-comment-block">; 1    ;; #TODO [#静的メンバ] [#遅延関数呼び出し]
</span>{ :a 1 :b 2
  :sum fn () + a b
} sum     <span class="code-attr-comment-block">; 3
</span>
&lt; <span class="code-attr-method">len</span>(<span class="code-attr-string">":v 9"</span>) <span class="code-attr-method">len</span>(<span class="code-attr-string">"= v 9"</span>)
<span class="code-attr-comment-block">; &lt; ":v 9".len "= v 9".len ; MARK: 可読性低い
</span>
<span class="code-attr-comment-block">;; #TODO
</span>assert = 1 {1}()
assert = 2 {1  2}()
assert = 1 {:v 1  2}().v  <span class="code-attr-comment-block">;; undefined == 2.v
</span>assert = 1 {:v 1  2  <span class="code-attr-type">this</span>}().v
assert = {:v 1}() {:v 1  <span class="code-attr-type">this</span>}()
assert = {:v 1}() {:v 1}().__this__

<span class="code-attr-comment-block">;; 問題 ;;
</span><span class="code-attr-comment-block">;; 一文字変数利用時にコメントとの区別がしずらくなる
</span><span class="code-attr-comment-block">;; コメント１
</span>:i ~~ $1 $2
<span class="code-attr-comment-block">;; コメント２
</span>:j ~~ $1 $2
<span class="code-attr-comment-block">;; 対応
</span>: i ~~ $1 $2
<span class="code-attr-comment-block">;; 対応
</span>$i ~~ $1 $2
<span class="code-attr-comment-block">;; 対応
</span>::<span class="code-attr-object">i</span> ~~ $1 $2


<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 静的メンバ
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #重要度 50%
</span><span class="code-attr-comment-block">;; #前提仕様 [#代入演算子の変更]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 関数オブジェクトへのメンバアクセス時について
</span><span class="code-attr-comment-block">;; 関数内の式中から対応する同名のローカル変数をメンバ変数として取得する
</span><span class="code-attr-comment-block">;;
</span>{:a 9}.a  <span class="code-attr-comment-block">; 9
</span>{:a 9}.b  <span class="code-attr-comment-block">; nil
</span>{|b| :a b}.a     <span class="code-attr-comment-block">; nil
</span>{|b| :a b}(2).a  <span class="code-attr-comment-block">; 2
</span>:b 8
:dic {:a b}
dic.a  <span class="code-attr-comment-block">; 8
</span>:b 7
dic.a  <span class="code-attr-comment-block">; 8?
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 遅延関数呼び出し
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #重要度 50%
</span><span class="code-attr-comment-block">;; #前提仕様 [#代入演算子の変更] [#束縛演算子の戻り値]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 関数オブジェクトを束縛した変数へのメンバアクセスが行われた際には
</span><span class="code-attr-comment-block">;; 関数オブジェクトの呼び出し結果を自身の変数に再束縛した上でメンバアクセスを行う
</span><span class="code-attr-comment-block">;;
</span>::<span class="code-attr-object">dic</span> {:a 9}
typeof dic  <span class="code-attr-comment-block">; Function(anonymous {:a 9})
</span>dic.a <span class="code-attr-comment-block">; 9
</span>typeof dic  <span class="code-attr-comment-block">; Map({:a 9})
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ラムダ宣言式の追加
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #重要度 75%
</span><span class="code-attr-comment-block">;; #関連仕様 [#演算子の用途変更] [#引数リスト]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; `||`をラムダ式に応用する
</span><span class="code-attr-comment-block">;; ラムダ式の出現箇所を強調する意図がある
</span><span class="code-attr-comment-block">;;    縦方向に広いグリフは目立ちやすいという特性を活かす
</span><span class="code-attr-comment-block">;; また引数追加時の対応がしやすくなるという利点がある
</span><span class="code-attr-comment-block">;;    `~~` --&gt; `~(arg)` ; before
</span><span class="code-attr-comment-block">;;    `||` --&gt; `|arg|`  ; after
</span><span class="code-attr-comment-block">;;
</span>= f || <span class="code-attr-keyword">echo</span> _ <span class="code-attr-comment-block">; 論理OR文を採用した言語との区別が面倒で煩わしい
</span>= g |v| <span class="code-attr-keyword">echo</span> v
f <span class="code-attr-string">"foo"</span> <span class="code-attr-comment-block">; foo
</span>g <span class="code-attr-string">"bar"</span> <span class="code-attr-comment-block">; bar
</span>{|v| <span class="code-attr-keyword">echo</span> v}
|v| {<span class="code-attr-keyword">echo</span> v} <span class="code-attr-comment-block">; `|`演算子との共存が難しい。カンマを必須にする必要がある
</span>{v| <span class="code-attr-keyword">echo</span> v}  <span class="code-attr-comment-block">; `|`一つではラムダ式としての認知のし易さに難点あり
</span>[v| <span class="code-attr-keyword">echo</span> v]  <span class="code-attr-comment-block">; `map(v| -v)`は綺麗だが曖昧、`map(|v| -v)`のほうが明確で認知効率が高い（とりわけ仮引数名が長くなる場合）
</span>[v]{<span class="code-attr-keyword">echo</span> v}  <span class="code-attr-comment-block">; 括弧を用いれば、どこからどこまでが仮引数リストの範囲なのかが明確
</span>&lt;v&gt;{<span class="code-attr-keyword">echo</span> v}  <span class="code-attr-comment-block">; `|`と`{}`の組み合わせはフォントによっては読みづらくなる
</span>             <span class="code-attr-comment-block">; `|`がベースライン寄りに描画されることがあるため
</span>             <span class="code-attr-comment-block">; 中央に表示される`&lt;&gt;`であれば安定
</span>             <span class="code-attr-comment-block">; 空白の記述も省略可能で安定した記述となる
</span>             <span class="code-attr-comment-block">; `{}`よりも`&lt;&gt;`のほうが縦に短いためバランスも良い（左向き三角のシルエット `&lt;&gt;{}`）
</span>{&lt;v&gt; <span class="code-attr-keyword">echo</span> v}
{&lt;&gt;.<span class="code-attr-keyword">echo</span>}
{<span class="code-attr-keyword">echo</span> &lt;&gt;}
<span class="code-attr-keyword">echo</span>&lt;&gt;
&lt;&gt;.<span class="code-attr-keyword">echo</span>
<span class="code-attr-method">f</span>(&lt;v&gt; <span class="code-attr-keyword">echo</span> v)
{+ &lt;&gt;}(1 2) <span class="code-attr-comment-block">; 3
</span>[1 2].fold 0 +&lt;&gt;
#v <span class="code-attr-keyword">echo</span> v
v # <span class="code-attr-keyword">echo</span> v
<span class="code-attr-method">each</span>(item, index # <span class="code-attr-keyword">echo</span> item)
<span class="code-attr-method">each</span>{#(item, index) <span class="code-attr-keyword">echo</span> item}
[].each (item index) #
  <span class="code-attr-keyword">echo</span> item

$ <span class="code-attr-keyword">echo</span> $0   <span class="code-attr-comment-block">;; #domain-specific
</span>{|a| $<span class="code-attr-keyword">echo</span> a _}(9)(8)     <span class="code-attr-comment-block">; "98"
</span>{|a| $(b) <span class="code-attr-keyword">echo</span> a b}(9)(8) <span class="code-attr-comment-block">; "98"
</span>
<span class="code-attr-comment-block">;; 糖衣構文
</span>= p ^<span class="code-attr-keyword">print</span> <span class="code-attr-string">"hello"</span> <span class="code-attr-comment-block">;; 案１
</span>= p ~<span class="code-attr-keyword">print</span> <span class="code-attr-string">"hello"</span> <span class="code-attr-comment-block">;; 案２
</span>= p #<span class="code-attr-keyword">print</span> <span class="code-attr-string">"hello"</span> <span class="code-attr-comment-block">;; 案３
</span><span class="code-attr-method">p</span>()                <span class="code-attr-comment-block">;; "hello"
</span>:p ^<span class="code-attr-keyword">print</span>
p <span class="code-attr-string">"hello"</span>          <span class="code-attr-comment-block">;; "hello"
</span>
<span class="code-attr-comment-block">;; 省略記法: `|`が後置されていた場合
</span><span class="code-attr-method">sort</span>(a b| &gt; a b)  <span class="code-attr-comment-block">; sort(|a b| &gt; a b)
</span>
<span class="code-attr-comment-block">;; 省略記法: `[]`がオペレータとして解釈可能な場合
</span>__typeof__  [a b] + a b  <span class="code-attr-comment-block">; Function
</span>__typeof__ [a b] + a b   <span class="code-attr-comment-block">; Array &amp; Expression
</span>
<span class="code-attr-comment-block">;; 合理性検証
</span>[].map |v| + 1 v
[].<span class="code-attr-method">map</span>{|v| + 1 v}.sort
[].<span class="code-attr-method">map</span>(|v| + 1 v).sort
[].<span class="code-attr-method">map</span>(&lt;v&gt; + 1 v).sort
[].<span class="code-attr-method">map</span>(|| + 1 _).sort
[].<span class="code-attr-method">map</span>(~~ + 1 _).sort

[].map&lt;+ 1&gt;.<span class="code-attr-method">map</span>{&lt;v&gt; + 1 v}
[].map&lt;+ 1&gt;.map &lt;v&gt; + 1 v
[].map&lt;[_ &lt;* 2&gt;]&gt;.map &lt;v w...&gt; + v w

[].<span class="code-attr-method">each</span>{<span class="code-attr-keyword">print</span> _}
[].<span class="code-attr-method">each</span>{<span class="code-attr-keyword">print</span> $0}
[].<span class="code-attr-method">each</span>{<span class="code-attr-keyword">print</span> &lt;&gt;}
[].each&lt;<span class="code-attr-keyword">print</span> {}&gt;
[].each &lt;&gt;.<span class="code-attr-keyword">print</span>  <span class="code-attr-comment-block">; 外部スコープを参照してしまっている
</span>[].each <span class="code-attr-keyword">print</span>&lt;&gt;   <span class="code-attr-comment-block">; 外部スコープを参照してしまっている
</span>[].each&lt;&gt;.<span class="code-attr-keyword">print</span>

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 段落結合
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #拡張機能  #重要度 50%  #影響度 75%
</span><span class="code-attr-comment-block">;; #用語案  [段落結合  後置結合]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 次の段落に出現する式を現在の式に対応する要素式として解釈させる
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; 案１ -- `key:`式がオペレータとして評価可能な場合は結合可能式と見なす
</span><span class="code-attr-keyword">if</span> <span class="code-attr-type">nil</span>
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"yes"</span>
<span class="code-attr-keyword">else</span>:
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"no"</span>
<span class="code-attr-comment-block">; before
</span><span class="code-attr-comment-block">;   (if nil (print "yes"))  (else: (print "no"))
</span><span class="code-attr-comment-block">; after（案１） -- 有力案
</span><span class="code-attr-comment-block">;   (if nil (print "yes") (else: print "no"))
</span><span class="code-attr-comment-block">; after（案２）
</span><span class="code-attr-comment-block">;   (if nil (print "yes") else: (print "no"))
</span>
<span class="code-attr-comment-block">;; 影響
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   Key型の定義と内部表現をより厳格に定める必要がある #TODO
</span><span class="code-attr-comment-block">;;     Symbol型、KeyValue型
</span><span class="code-attr-comment-block">;;   キーワードに対する`:`前置記法と後置記法に異なる意味を持たせる
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 対応案
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   `:key val` -&gt; (: key val)    ;; 従来通りMap型への糖衣構文
</span><span class="code-attr-comment-block">;;   `key: val` -&gt; ((key:) (val)) ;; 一意のオブジェクト
</span><span class="code-attr-comment-block">;;   `key: val` -&gt; (key: val)     ;; オペレータとして扱う
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 応用例
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   ベースクラスの指定
</span><span class="code-attr-comment-block">;;     `class Integer: Number`
</span><span class="code-attr-comment-block">;;   型の明示
</span><span class="code-attr-comment-block">;;     `func join (separator: String items: Array)`
</span><span class="code-attr-comment-block">;;   名前付き引数
</span><span class="code-attr-comment-block">;;      print 1 2 separator: ","  ; (print 1 2 (separator: ","))
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 実行時評価
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   = key :KEY
</span><span class="code-attr-comment-block">;;   print key:    ; ??? :key
</span><span class="code-attr-comment-block">;;   print :key    ; ??? :KEY
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; キー型
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;    `:`が前置された場合は単純なキー型として扱う
</span><span class="code-attr-comment-block">;;    式は値として評価される
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;       = map (:a 1 :b 2)
</span><span class="code-attr-comment-block">;;       map.0  ; Key(:a)
</span><span class="code-attr-comment-block">;;       map.3  ; Number(2)
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; セル型
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;    `:`が後置された場合はオペレータとして扱う
</span><span class="code-attr-comment-block">;;    式はオペランドを内包するリスト型として評価される
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;       class Array
</span><span class="code-attr-comment-block">;;         fn __doesNotUnderstand__ (a b c)
</span><span class="code-attr-comment-block">;;           if &amp; = a.0 :setObject
</span><span class="code-attr-comment-block">;;                = b.0 :atIndex
</span><span class="code-attr-comment-block">;;             Array_insertValueAtIndex(__raw__  b.1  a.1)
</span><span class="code-attr-comment-block">;;             throw "unrecognized selector"
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;       ([] setObject:"a" atIndex:0)
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 可読性に関する実験
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   alpha: 1 beta: 2 --&gt; alpha: 1, beta: 2
</span><span class="code-attr-comment-block">;;   alpha:1 beta:2   --&gt; シンタックスハイライトを効かせればカンマ不要
</span><span class="code-attr-comment-block">;;   :alpha 1 :beta 2 --&gt; `:`が区切り文字の替わりになるためカンマ不要
</span><span class="code-attr-comment-block">;;   :ary["key"] "val" --&gt; 代入処理としての明確さは高い
</span><span class="code-attr-comment-block">;;   ary["key"]: "val"
</span><span class="code-attr-comment-block">;;   :key "val" --&gt; 関数呼び出しと解釈される恐れがあり
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 末尾要素式に対する後置`:`の解釈
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;     影響：[#セル型]
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   複要素式の末尾に`:`が記述された場合
</span><span class="code-attr-comment-block">;;   以降の階層を一続きのブロックとみなす
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;      if = no nil:   ;; 出力："no"
</span><span class="code-attr-comment-block">;;         print "n"
</span><span class="code-attr-comment-block">;;         print "o"
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   インデントが二重の場合はセル型として解釈する
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;      if true then:
</span><span class="code-attr-comment-block">;;          yes
</span><span class="code-attr-comment-block">;;        else:
</span><span class="code-attr-comment-block">;;          no
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   末尾コロンの利用には、条件部と処理部の区別を容易にする目的がある
</span><span class="code-attr-comment-block">;;   コロンが後置された行の次の行では字下げが行われていることが自明であるため
</span><span class="code-attr-comment-block">;;   両行が異なる領域に記述された処理であることが直感的に理解できるようになる
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;      = vl mc_fn_a()
</span><span class="code-attr-comment-block">;;      if = vl fn_b():  ;; 制御文であることが直感的に理解できる
</span><span class="code-attr-comment-block">;;        print fn_c()   ;; コロンの後なので、字下げされていることがすぐに分かる
</span><span class="code-attr-comment-block">;;      ;; 上記のインデントを確認せずとも、コロンの有無だけで字下げを判断することができる
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   `;`の他、` :`や`,`の利用も検討する
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; 案２ -- 段落間の改行が省略された場合に前後の式を結合する
</span><span class="code-attr-comment-block">; (if nil (print "yes") (else print "no"))
</span>= <span class="code-attr-keyword">else</span> #:<span class="code-attr-keyword">else</span>
<span class="code-attr-keyword">if</span> <span class="code-attr-type">nil</span>
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"yes"</span>
<span class="code-attr-keyword">else</span>
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"no"</span>
<span class="code-attr-comment-block">; (if nil (print "yes"))  (else print "no"))
</span><span class="code-attr-keyword">if</span> <span class="code-attr-type">nil</span>
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"yes"</span>

<span class="code-attr-keyword">else</span>
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"no"</span>

<span class="code-attr-comment-block">;; 案２-３
</span><span class="code-attr-keyword">if</span> = no <span class="code-attr-type">nil</span>:
   <span class="code-attr-keyword">print</span> <span class="code-attr-string">"no"</span>
elif = yes <span class="code-attr-type">true</span>:
   <span class="code-attr-keyword">print</span> <span class="code-attr-string">"yes"</span>

<span class="code-attr-comment-block">;; その他
</span><span class="code-attr-label">value</span>:
  <span class="code-attr-label">a</span>: <span class="code-attr-string">"a"</span>
  + a <span class="code-attr-string">"b"</span>
<span class="code-attr-keyword">print</span> value <span class="code-attr-comment-block">; "ab"
</span>
<span class="code-attr-comment-block">; #TODO
</span><span class="code-attr-comment-block">; 空行の記述を容認した場合
</span><span class="code-attr-comment-block">; 変数初期化式が段落結合の対象になってしまう問題あり
</span><span class="code-attr-keyword">if</span> yes
  <span class="code-attr-keyword">print</span> <span class="code-attr-string">"yes"</span>

<span class="code-attr-label">elsa</span>:
  <span class="code-attr-string">"Elsa"</span>

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 型の明示
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 空白を挟まない`要素:型名`記法が用いられていた場合、
</span><span class="code-attr-comment-block">;; インタプリタ側では`:型名`の部分を無視する
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-keyword">func</span> makeView (<span class="code-attr-label">point</span>:<span class="code-attr-object">Point</span> <span class="code-attr-label">size</span>:<span class="code-attr-object">Size</span>):<span class="code-attr-object">View</span>
  (<span class="code-attr-object">View</span> point size)

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 型システム
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; [#型の明示]を正式な型システムに取り入れる場合は、
</span><span class="code-attr-comment-block">;; 仮引数のインターフェースを厳格に定める必要がある
</span><span class="code-attr-comment-block">;;  - Key型の仕組みを活用する
</span><span class="code-attr-comment-block">;;  - または式型の仕組みに取り込む  #2017-01-08
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 代替案 [#ブロック・コメント]
</span><span class="code-attr-comment-block">;;  型情報をコメントとして記述する
</span><span class="code-attr-comment-block">;;  型情報は静的解析時等に活用する
</span><span class="code-attr-comment-block">;;
</span>= <span class="code-attr-keyword">func</span> ~ (name #params ...)
         = $local[name] (fn #params ...)
         #params
# params (<span class="code-attr-keyword">func</span> makeView (<span class="code-attr-label">point</span>:<span class="code-attr-object">Point</span> <span class="code-attr-label">size</span>:<span class="code-attr-object">Size</span>):<span class="code-attr-object">View</span> <span class="code-attr-type">nil</span>)
#params[0]  <span class="code-attr-comment-block">; {:type Point :name point}
</span>#params[1]  <span class="code-attr-comment-block">; {:type Size  :name size }
</span><span class="code-attr-comment-block">; 案１
</span>#params.type    <span class="code-attr-comment-block">; View
</span>#params.name    <span class="code-attr-comment-block">; nil
</span><span class="code-attr-comment-block">; 案２
</span>#params.type    <span class="code-attr-comment-block">; Array
</span>#params.attr    <span class="code-attr-comment-block">; {:type Object :some View}
</span>(#(():[:a <span class="code-attr-string">"1"</span> :b <span class="code-attr-string">"2"</span>])).attr
  <span class="code-attr-comment-block">; {:type Map :some [:a "1" :b "2"]}
</span><span class="code-attr-keyword">class</span> <span class="code-attr-label">Sub</span>: <span class="code-attr-object">Super</span>, <span class="code-attr-object">Equatable</span>
  <span class="code-attr-keyword">func</span> equals (a): [<span class="code-attr-label">type</span>:<span class="code-attr-object">Bool</span> <span class="code-attr-keyword">throws</span>:<span class="code-attr-object">IllegalArgumentException</span>]
    <span class="code-attr-method">Bool</span>(== <span class="code-attr-type">self</span> a)
  <span class="code-attr-keyword">func</span> <span class="code-attr-method">copy</span>(<span class="code-attr-label">from</span>: [<span class="code-attr-keyword">const</span>, <span class="code-attr-object">String</span>] <span class="code-attr-label">to</span>: [<span class="code-attr-label">type</span>: <span class="code-attr-object">String</span>])
    sweetassert (#from).attr.<span class="code-attr-method">contains</span>(<span class="code-attr-keyword">const</span>)
    __builtin__[<span class="code-attr-string">"libc/string.h"</span>].strcpy to.__raw__ from.__raw__
  <span class="code-attr-keyword">func</span> <span class="code-attr-keyword">print</span> (<span class="code-attr-label">terminator</span>: [<span class="code-attr-label">default</span>:<span class="code-attr-string">"\n"</span>])
    <span class="code-attr-keyword">print</span> <span class="code-attr-label">value</span>: <span class="code-attr-type">self</span>
          <span class="code-attr-label">separator</span>: <span class="code-attr-string">", "</span>
          <span class="code-attr-label">terminator</span>: terminator

<span class="code-attr-keyword">func</span> <span class="code-attr-method">add</span>(a b): [<span class="code-attr-object">Int</span> <span class="code-attr-object">Int</span> <span class="code-attr-object">String</span>]
  <span class="code-attr-method">String</span>(+ a b)
<span class="code-attr-keyword">func</span> <span class="code-attr-method">add</span>(a b): [<span class="code-attr-label">a</span>:<span class="code-attr-object">Int</span> <span class="code-attr-label">b</span>:<span class="code-attr-object">Int</span> <span class="code-attr-object">String</span>]
  <span class="code-attr-method">String</span>(+ a b)
<span class="code-attr-keyword">func</span> <span class="code-attr-method">add</span>(a b) <span class="code-attr-comment-block">;(Int Int String)
</span>  <span class="code-attr-method">String</span>(+ a b)

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 名前付き引数
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; [#型システム]との整合性も意識する
</span><span class="code-attr-comment-block">;;
</span>(<span class="code-attr-object">View</span> <span class="code-attr-label">point</span>:(2 3) <span class="code-attr-label">size</span>:(600 450))  <span class="code-attr-comment-block">; 案１
</span>(<span class="code-attr-object">View</span> (2 3):point (600 450):size)  <span class="code-attr-comment-block">; 案２
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 糖衣構文（辞書型）
</span><span class="code-attr-comment-block">;;
</span>= bob :name <span class="code-attr-string">"bob"</span> :age 16  <span class="code-attr-comment-block">; = bob {name:"bob", age:16}
</span>= tom :name <span class="code-attr-string">"tom"</span>
      :age 32

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 糖衣構文（$）
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 50%  #影響度 0%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; `$`で始まる変数をメンバアクセスの糖衣構文にする
</span><span class="code-attr-comment-block">;;
</span>$<span class="code-attr-keyword">static</span>    <span class="code-attr-comment-block">;; this["__static__"]
</span>{<span class="code-attr-keyword">echo</span> $0}  <span class="code-attr-comment-block">;; ~~ echo this["__0__"]
</span>{$length}(1 1) <span class="code-attr-comment-block">; 2
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 糖衣構文（_）
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #多様性 #重要度 40%  #影響度 1%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; `_`で始まる数値を仮引数の糖衣構文にする
</span><span class="code-attr-comment-block">;;   ただし、可読性が低く、数値として認知されやすいという欠点がある
</span><span class="code-attr-comment-block">;;   その他、メンバ変数との競合あり
</span><span class="code-attr-comment-block">;;   [#糖衣構文（$）]の応用を視野に入れる
</span><span class="code-attr-comment-block">;;
</span>{<span class="code-attr-keyword">echo</span> _0}  <span class="code-attr-comment-block">;; ~~ echo this["__0__"]
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; コメント
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">; inline comment
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ブロック・コメント
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; `;`に続く文字が開始括弧で始まる場合、ブロックコメントの開始コメントと見なす
</span><span class="code-attr-comment-block">;; `;`に続く文字が閉じ括弧で始まる場合、ブロックコメントの終了コメントと見なす
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;; 例
</span>
<span class="code-attr-comment-block">;( block comment ;)
</span><span class="code-attr-comment-block">;( block comment  )    ;; 検討中（インライン時限定）
</span><span class="code-attr-comment-block">;[ block comment ;]
</span><span class="code-attr-comment-block">;| inline comment ;|
</span><span class="code-attr-comment-block">; ( inline comment ;)
</span><span class="code-attr-comment-block">; [ inline comment ;]
</span>
<span class="code-attr-comment-block">;; 応用例（ネスト）
</span>
<span class="code-attr-comment-block">;{
</span>  memberof <span class="code-attr-string">";{;}"</span>
  <span class="code-attr-comment-block">;[
</span>    memberof <span class="code-attr-string">";[;]"</span>
  <span class="code-attr-comment-block">;]
</span>  memberof <span class="code-attr-string">";{;}"</span>
<span class="code-attr-comment-block">;}
</span>
<span class="code-attr-comment-block">;; 応用例（トグル）
</span>
<span class="code-attr-comment-block">;[
</span><span class="code-attr-keyword">echo</span> <span class="code-attr-string">"i was here"</span>
<span class="code-attr-comment-block">;]
</span>
<span class="code-attr-comment-block">; [
</span><span class="code-attr-keyword">echo</span> <span class="code-attr-string">"i am here"</span>
<span class="code-attr-comment-block">;]
</span>

<span class="code-attr-comment-block">;(echo
</span>  <span class="code-attr-string">"i was here"</span>
)
  
(<span class="code-attr-keyword">echo</span>
  <span class="code-attr-string">"here i am"</span>
)

<span class="code-attr-comment-block">;; 応用例（アノテーション、型情報）
</span>
<span class="code-attr-comment-block">;(override) func sound ();String
</span>  <span class="code-attr-string">"nyan"</span>
<span class="code-attr-keyword">func</span> strcpy (<span class="code-attr-label">from</span>:<span class="code-attr-object">String</span><span class="code-attr-comment-block">;(nonnull) to:String;nonnull
</span>            ):<span class="code-attr-object">String</span><span class="code-attr-comment-block">;(nullable, overloadable) {}
</span>
<span class="code-attr-comment-block">; @(override) func sound () @String "nyan"
</span><span class="code-attr-comment-block">; func strcpy (from:String@(nonnull) to:String @nonnull
</span><span class="code-attr-comment-block">;             ):String @(nullable, overloadable) {}
</span>
<span class="code-attr-comment-block">;; 拡張案
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  `(; &lt;expression&gt;...)`式をコメントとする
</span><span class="code-attr-comment-block">;;
</span>(<span class="code-attr-comment-block">; (print "a") )
</span>
(<span class="code-attr-comment-block">;
</span>  (<span class="code-attr-keyword">print</span> <span class="code-attr-string">"a"</span>)
  (<span class="code-attr-keyword">print</span> <span class="code-attr-string">"b"</span>)
)

(<span class="code-attr-comment-block">;if yes
</span>  <span class="code-attr-string">"y"</span>
  <span class="code-attr-string">"n"</span>)

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ドキュメント・コメント
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;;# heading
</span><span class="code-attr-comment-block">;;- item-1
</span><span class="code-attr-comment-block">;;- item-2
</span><span class="code-attr-comment-block">;;## subheading
</span><span class="code-attr-comment-block">;;| A B
</span><span class="code-attr-comment-block">;;| C D
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;
</span><span class="code-attr-comment-block">; # heading
</span><span class="code-attr-comment-block">;  - item-1
</span><span class="code-attr-comment-block">;  - item-2
</span><span class="code-attr-comment-block">; ## subheading
</span><span class="code-attr-comment-block">;  | A B
</span><span class="code-attr-comment-block">;  | C D
</span><span class="code-attr-comment-block">;
</span><span class="code-attr-comment-block">; ~~~ js ~~~~~~~~~~~~~~~
</span><span class="code-attr-comment-block">; var f = (i) =&gt; i * 2
</span><span class="code-attr-comment-block">; ~~~~~~~~~~~~~~~~~~~~~~
</span><span class="code-attr-comment-block">;

</span><span class="code-attr-comment-block">;; 変換後
</span>
<span class="code-attr-comment-block">; &lt;h1&gt;split&lt;/h1&gt;
</span><span class="code-attr-comment-block">; &lt;ul&gt;&lt;li&gt;item-1&lt;/li&gt;
</span><span class="code-attr-comment-block">;     &lt;li&gt;item-2&lt;/li&gt;&lt;/ul&gt;
</span><span class="code-attr-comment-block">; &lt;table&gt;&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt;&lt;/tr&gt;
</span><span class="code-attr-comment-block">;        &lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;D&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; その他
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 関数をオブジェクトとして渡すための記法
</span>call + 1 2   <span class="code-attr-comment-block">; (call (+ 1 2))
</span>call +, 1 2  <span class="code-attr-comment-block">; (call + 1 2)
</span>call (+) 1 2 <span class="code-attr-comment-block">; 代替案２
</span>call #+ 1 2  <span class="code-attr-comment-block">; 代替案３
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 基本型
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-string">""</span>      <span class="code-attr-comment-block">; String
</span>1       <span class="code-attr-comment-block">; Number
</span>3.1     <span class="code-attr-comment-block">; Number
</span>:a      <span class="code-attr-comment-block">; Key
</span>(1 2)   <span class="code-attr-comment-block">; List
</span>[1 2]   <span class="code-attr-comment-block">; Array
</span>[:a 1]  <span class="code-attr-comment-block">; Map
</span>{_}     <span class="code-attr-comment-block">; Function
</span>~~ _    <span class="code-attr-comment-block">; Function
</span>~ (v) v <span class="code-attr-comment-block">; Function
</span>|v| v   <span class="code-attr-comment-block">; Function
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 基本構文
</span><span class="code-attr-comment-block">;;
</span>+ a b   <span class="code-attr-comment-block">; 演算子呼び出し
</span>f a     <span class="code-attr-comment-block">; 関数呼び出し
</span><span class="code-attr-method">f</span>(a)    <span class="code-attr-comment-block">; 前置呼び出し
</span>v.m     <span class="code-attr-comment-block">; プロパティ呼び出し
</span>a  b    <span class="code-attr-comment-block">; インライン・インデント
</span><span class="code-attr-label">k</span>: v    <span class="code-attr-comment-block">; 複合文
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 標準ライブラリ
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; operator
</span><span class="code-attr-keyword">func</span> + (a ...b) __builtin__.<span class="code-attr-keyword">operator</span>[<span class="code-attr-string">"ADD"</span>] a ...b
<span class="code-attr-keyword">func</span> - (a ...b) __builtin__.<span class="code-attr-keyword">operator</span>[<span class="code-attr-string">"SUB"</span>] a ...b
<span class="code-attr-keyword">func</span> * (a ...b) __builtin__.<span class="code-attr-keyword">operator</span>[<span class="code-attr-string">"MUL"</span>] a ...b
<span class="code-attr-keyword">func</span> / (a ...b) __builtin__.<span class="code-attr-keyword">operator</span>[<span class="code-attr-string">"DIV"</span>] a ...b
<span class="code-attr-keyword">func</span> == (a b)   __builtin__.<span class="code-attr-keyword">operator</span>[<span class="code-attr-string">"EQ"</span>] a b
<span class="code-attr-keyword">func</span> = (a b)    __builtin__.<span class="code-attr-keyword">operator</span>[<span class="code-attr-string">"ASSIGN"</span>] a b

<span class="code-attr-comment-block">;; if
</span><span class="code-attr-keyword">func</span> <span class="code-attr-keyword">if</span> (c #t #e) ? c #t #e
<span class="code-attr-comment-block">;; while
</span><span class="code-attr-keyword">func</span> <span class="code-attr-keyword">while</span> (c #s) <span class="code-attr-keyword">if</span> c (<span class="code-attr-keyword">do</span> s (<span class="code-attr-type">this</span> #c #s))
<span class="code-attr-comment-block">;; do
</span><span class="code-attr-keyword">func</span> <span class="code-attr-keyword">do</span> (v ...w) &amp; v ...w
<span class="code-attr-comment-block">;; cond
</span><span class="code-attr-keyword">func</span> cond (a ...b)
   :validate ~~ <span class="code-attr-keyword">if</span> (== 1 _0) <span class="code-attr-method">_1</span>()
   :iterate  ~~ [ary f]
      :next ary
      <span class="code-attr-keyword">while</span> next <span class="code-attr-label">then</span>:
         <span class="code-attr-keyword">break</span> (<span class="code-attr-keyword">if</span> (f next.car))
         <span class="code-attr-keyword">break</span> (<span class="code-attr-keyword">if</span> (:next next.cdr))
   <span class="code-attr-keyword">if</span> = <span class="code-attr-string">"List"</span> (typeof a) [
      iterate b #(<span class="code-attr-keyword">if</span> (_[0] <span class="code-attr-type">nil</span>) (<span class="code-attr-keyword">return</span> _[1]))
   ] <span class="code-attr-keyword">if</span> = <span class="code-attr-string">"Map"</span> (typeof a) [
      <span class="code-attr-keyword">if</span> = :is a.keys.first
         iterate b #(<span class="code-attr-keyword">if</span> (= a (_[0] <span class="code-attr-type">nil</span>))  <span class="code-attr-keyword">return</span> _[1])
         iterate b #(<span class="code-attr-keyword">if</span> (_[0] a)          <span class="code-attr-keyword">return</span> _[1])
   ]
   (<span class="code-attr-label">none</span>:)
<span class="code-attr-comment-block">;; switch
</span><span class="code-attr-keyword">func</span> <span class="code-attr-keyword">switch</span> (a ...) (cond (<span class="code-attr-label">is</span>:a) ...)
<span class="code-attr-keyword">func</span> <span class="code-attr-keyword">switch</span> (a ...)
  <span class="code-attr-keyword">if</span> ! (<span class="code-attr-label">none</span>:) (cond (<span class="code-attr-label">is</span>:a) ...)
    <span class="code-attr-keyword">do</span> (<span class="code-attr-method">filter</span>{= <span class="code-attr-label">default</span>:}|reverse ...).car.cdr
<span class="code-attr-comment-block">;; test cond "List"
</span>assert <span class="code-attr-string">"b"</span> cond
             (= 0 1) <span class="code-attr-string">"a"</span>
             (= 1 1) <span class="code-attr-string">"b"</span>
             (<span class="code-attr-type">true</span>)  <span class="code-attr-string">"default"</span>
<span class="code-attr-comment-block">;; test cond:with
</span>assert <span class="code-attr-string">"b"</span> cond <span class="code-attr-label">with</span>:1
             (= 0 _) <span class="code-attr-string">"a"</span>
             (= 1 ta_) <span class="code-attr-string">"b"</span>
             (<span class="code-attr-type">true</span>)  <span class="code-attr-string">"default"</span>
<span class="code-attr-comment-block">;; test cond:is
</span>assert <span class="code-attr-string">"b"</span> cond <span class="code-attr-label">is</span>:1
             (0) <span class="code-attr-string">"a"</span>
             (1) <span class="code-attr-string">"b"</span>
<span class="code-attr-comment-block">;; test switch
</span>assert <span class="code-attr-string">"b"</span> <span class="code-attr-keyword">switch</span> 1
             (0) <span class="code-attr-string">"a"</span>
             (1) <span class="code-attr-string">"b"</span>
             :2  <span class="code-attr-string">"c"</span>
             :3  <span class="code-attr-string">"d"</span>
assert <span class="code-attr-string">"x"</span> <span class="code-attr-keyword">switch</span> 9
             (0) <span class="code-attr-string">"a"</span>  (1) <span class="code-attr-string">"b"</span>
             (2) <span class="code-attr-string">"c"</span>  (3) <span class="code-attr-string">"d"</span>
             (<span class="code-attr-label">default</span>:) <span class="code-attr-string">"x"</span>
assert <span class="code-attr-string">"x"</span> <span class="code-attr-keyword">switch</span> 9 (_) <span class="code-attr-string">"x"</span>
assert  9  <span class="code-attr-keyword">switch</span> 9 (_)  _

<span class="code-attr-comment-block">;; String
</span><span class="code-attr-keyword">class</span> <span class="code-attr-label">String</span>: <span class="code-attr-label">_s</span>: []
  <span class="code-attr-keyword">func</span> <span class="code-attr-keyword">operator</span>.<span class="code-attr-keyword">ADD</span>       (s) _s.copy.<span class="code-attr-method">add</span>(s)
<span class="code-attr-keyword">func</span> <span class="code-attr-object">String</span>.<span class="code-attr-keyword">operator</span>.<span class="code-attr-keyword">SUB</span>  (s) - _s.<span class="code-attr-type">int</span>   s
<span class="code-attr-keyword">func</span> <span class="code-attr-object">String</span>.<span class="code-attr-keyword">operator</span>.`*`  (s) * <span class="code-attr-type">int</span>(_s)  s
<span class="code-attr-keyword">func</span> <span class="code-attr-object">String</span>.`/`           (s) / _s.<span class="code-attr-type">float</span> s

<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 予約語
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  今後の言語拡張を想定し、いくつかの演算子およびキーワードを予約語とする
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  以下の演算子・記号・識別子をコア言語側の予約語とする
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  | 一般的な演算子 (+ - * / &amp; % etc.)
</span><span class="code-attr-comment-block">;;  | (? ?? ?: : ~ ~~ ` \ _ $ @ #)
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 準予約語
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  ライブラリ側での利用を想定し、以下のキーワードを準予約語とする
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  | "_", "$" で始まる全ての識別子
</span><span class="code-attr-comment-block">;;  | (fn func fun class struct)
</span><span class="code-attr-comment-block">;;  | (ret return break)
</span><span class="code-attr-comment-block">;;  | (in it is as eq has)
</span><span class="code-attr-comment-block">;;  | (then else end)
</span><span class="code-attr-comment-block">;;  | (not or and)
</span><span class="code-attr-comment-block">;;  | (self this that)
</span><span class="code-attr-comment-block">;;  | (may be to do)
</span><span class="code-attr-comment-block">;;  | (yes no T nil)
</span><span class="code-attr-comment-block">;;  | (typeof void)
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  | (category extension/exte)
</span><span class="code-attr-comment-block">;;  | その他、一般的な言語の予約後（interface implements etc.）
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 想定される予約語／準予約語の利用用途
</span><span class="code-attr-comment-block">;;
</span>? <span class="code-attr-string">"cond"</span>
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"then"</span>
  <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"else"</span>
= f ~~ <span class="code-attr-keyword">echo</span> _
f 99   <span class="code-attr-comment-block">; "99"
</span>{<span class="code-attr-keyword">echo</span> it} 99             <span class="code-attr-comment-block">; 99
</span>{<span class="code-attr-keyword">echo</span> $} 99              <span class="code-attr-comment-block">; 99
</span><span class="code-attr-keyword">do</span> {<span class="code-attr-keyword">echo</span> <span class="code-attr-string">"a"</span>} {<span class="code-attr-keyword">echo</span> <span class="code-attr-string">"b"</span>} <span class="code-attr-comment-block">; "ab"
</span><span class="code-attr-keyword">do</span> ((= a 1) (+ a 2))     <span class="code-attr-comment-block">; 3
</span>typeof <span class="code-attr-string">""</span>  <span class="code-attr-comment-block">; String
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; fnキーワードは予約後にしない方針
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 組み込みのラムダ式は`~~`, `~ ()`, `{}`に限定
</span><span class="code-attr-comment-block">;; fnキーワードとシンボル名が連続して記述されると読みづらい
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">; こちらよりも
</span>= tn fn (a b) + a b
call fn (a b) + a b
<span class="code-attr-comment-block">; こちらのほうが明瞭で読みやすい
</span>= tn ~~ (a b) + a b
call ~~ (a b) + a b
<span class="code-attr-comment-block">;; MEMO: サンドイッチのような（キーワード オペレーター キーワード オペレーター）記述を意識するとメリハリが付いて読みやすいコードになる
</span><span class="code-attr-comment-block">; NG
</span>+  + a b  c
<span class="code-attr-keyword">if</span> eq a b  1 2
<span class="code-attr-comment-block">; Good
</span>add + a b  c
<span class="code-attr-keyword">if</span> == a b  1 2
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; ライブラリ側でfuncとfnの定義を区別することができる
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 関数宣言（引数明示しない）
</span><span class="code-attr-keyword">func</span> add + _0 _1
<span class="code-attr-comment-block">;; 関数宣言（引数明示する）
</span>fn add (a b) + a b

<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; TODO
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  重要度低め。要整理統合。
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  チェインケース
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   `-`記号による連結記法をサポートする
</span><span class="code-attr-comment-block">;;     | シンボル名　 | `/[a-zA-Z_]+-\w+/`
</span><span class="code-attr-comment-block">;;     | 未規定　　　 | `/[a-zA-Z_]+-/`
</span><span class="code-attr-comment-block">;;     | 未規定　　　 | `/-[a-zA-Z_]+(-\w+)*/`
</span><span class="code-attr-comment-block">;;     | 未規定　　　 | `/\d+-\w+/`
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   関連案・代替案
</span><span class="code-attr-comment-block">;;     - [#名前解決]
</span><span class="code-attr-comment-block">;;     - [#プリプロセッサ] ; TODO
</span><span class="code-attr-comment-block">;;   影響
</span><span class="code-attr-comment-block">;;     - [#カテゴリー式、グループ式]
</span><span class="code-attr-comment-block">;;   関連
</span><span class="code-attr-comment-block">;;     - [#演算子束縛]
</span><span class="code-attr-comment-block">;;
</span>
= variable-name <span class="code-attr-string">"value"</span> <span class="code-attr-comment-block">; 可能
</span>3-1   <span class="code-attr-comment-block">; 3.operator-(1)  ; 不可
</span>3 - 1 <span class="code-attr-comment-block">; 3.operator-(1)  ; 可能
</span>
<span class="code-attr-comment-block">;; プリプロセッサで実現予定の宣言文
</span>extension <span class="code-attr-object">String</span>+<span class="code-attr-method">classMethod</span>()     <span class="code-attr-keyword">puts</span> <span class="code-attr-string">"Class Method"</span>
extension <span class="code-attr-object">String</span>-<span class="code-attr-method">instanceMethod</span>()  <span class="code-attr-keyword">puts</span> <span class="code-attr-string">"Instance Method"</span>
<span class="code-attr-object">String</span>.<span class="code-attr-method">classMethod</span>() <span class="code-attr-comment-block">; "Class Method" 
</span><span class="code-attr-string">""</span>.<span class="code-attr-method">instanceMethod</span>()  <span class="code-attr-comment-block">; "Instance Method"
</span>
<span class="code-attr-comment-block">;; 名前解決への応用を視野に入れる
</span><span class="code-attr-comment-block">;; 影響 - [#前置呼び出し]
</span><span class="code-attr-keyword">enum</span> <span class="code-attr-object">Align</span>
  <span class="code-attr-object">Left</span>
  <span class="code-attr-object">Right</span>

:align <span class="code-attr-object">Align</span>-<span class="code-attr-object">Left</span>
<span class="code-attr-keyword">switch</span> align
  :-<span class="code-attr-object">Left</span>  <span class="code-attr-string">"L"</span>
  :-<span class="code-attr-object">Right</span> <span class="code-attr-string">"R"</span>
  -<span class="code-attr-object">Left</span>  <span class="code-attr-string">"L"</span>
  -<span class="code-attr-object">Right</span> <span class="code-attr-string">"R"</span>

:<span class="code-attr-object">Left</span> <span class="code-attr-string">"Left"</span>
assert! align  <span class="code-attr-object">Left</span>
assert= align -<span class="code-attr-object">Left</span>
assert= align  <span class="code-attr-object">Left</span>-

<span class="code-attr-comment-block">;; 束縛記法としての応用
</span><span class="code-attr-comment-block">;; 関連: [#演算子束縛] [#カテゴリー式、グループ式]
</span>:eq {= _0 _1}
<span class="code-attr-comment-block">; before
</span>assert (eq 1 2)
assert  eq 1 2
<span class="code-attr-comment-block">; after
</span>assert-eq 1 2

<span class="code-attr-keyword">print</span>-add 1 2 3  <span class="code-attr-comment-block">; (print (add 1 2 3))
</span><span class="code-attr-keyword">print</span>-add 1 2  3 <span class="code-attr-comment-block">; (print (add 1 2) 3)
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; プリプロセッサ
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; #コア機能  #重要度 100%  #影響度 0%
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   基本構文を拡張するための仕組み
</span><span class="code-attr-comment-block">;;   宣言文を独自に定義できるようにする
</span><span class="code-attr-comment-block">;;   ユーザ定義の記法を事前にパースさせる仕組みが必要
</span><span class="code-attr-comment-block">;;   糖衣構文の実現を可能とする
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   予約語 案: [macro define/def/dyndef expression/expr/static_expression syntax/dynamic_syntax]
</span><span class="code-attr-comment-block">;;
</span>expression `/([a-zA-<span class="code-attr-object"><span class="code-attr-keyword">Z_</span></span>])+-(\w+)/` ($1 $2)
  <span class="code-attr-comment-block">; dynamic_syntax_tree_register_symbol($1 "-" $2)
</span>  __dst__.create_symbol_begin
  __dst__.create_symbol_append $1
  __dst__.create_symbol_append <span class="code-attr-string">"-"</span>
  __dst__.create_symbol_append $2
  __dst__.create_symbol_end

(typeof symbol-name) <span class="code-attr-comment-block">; "Symbol"
</span>
expression `#assert` ()
  __dst__.<span class="code-attr-method">create_function_begin</span>()
  __dst__.<span class="code-attr-method">create_function_add_return</span>(<span class="code-attr-string">"void"</span>)
  __dst__.<span class="code-attr-method">create_function_add_parameter</span>(<span class="code-attr-string">"bool"</span>)
  __dst__.<span class="code-attr-method">create_function_add_callback</span>{ expr |
    __builtin__.<span class="code-attr-method">assert</span>(expr)
  }
  __dst__.<span class="code-attr-method">create_function_end</span>()

#<span class="code-attr-method">assert</span>(eq 1 2)

= f #assert
<span class="code-attr-method">f</span>(eq 1 2)

<span class="code-attr-comment-block">;; コーディング規約の表明
</span>expression `<span class="code-attr-keyword">if</span>` ()
  <span class="code-attr-keyword">if</span> == (=) (typeof __dst__.cdr.car)
    __dst__.static_assert <span class="code-attr-string">"assignment in conditional expression"</span>

<span class="code-attr-keyword">if</span> (= encoding <span class="code-attr-object"><span class="code-attr-keyword">UTF8</span></span>) <span class="code-attr-string">"y"</span> <span class="code-attr-string">"n"</span> <span class="code-attr-comment-block">; failed: assignment in conditional expression
</span>
<span class="code-attr-comment-block">;; 糖衣構文の定義
</span>expression `{` &lt;expression&gt;* `|` &lt;expression&gt;* `}` ($)
  ? __dst__.<span class="code-attr-method">register_expression_exist</span>($)
    __dst__.<span class="code-attr-method">register_expression_begin</span>($)
    __dst__.<span class="code-attr-method">create_lambda_begin</span>()
    __dst__.create_lambda_add_parameters $.nonterminal_symbols.0
    __dst__.create_lambda_add_body       $.nonterminal_symbols.1
    __dst__.<span class="code-attr-method">create_lambda_end</span>()
    __dst__.<span class="code-attr-method">register_expression_end</span>($)

{a b| + a b} 1 2 <span class="code-attr-comment-block">; 3
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 可変長演算子
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   連続する演算子の多重定義を可能とする
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-keyword">operator</span> `-` (n)
  <span class="code-attr-keyword">switch</span> n
    :1 (-)
    :2 (--)
    :3 (~~ (#ignore) <span class="code-attr-keyword">void</span>)

- 9   <span class="code-attr-comment-block">; -9
</span>--- <span class="code-attr-string">"i was here"</span>

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 関数オーバーロード
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 型の種類と引数リストのサイズによるオーバーロード解決
</span><span class="code-attr-comment-block">;;
</span>
+= max {a  | $ max a $0}    <span class="code-attr-comment-block">;; A
</span>+= max {a b| ? (&gt; a b) a b} <span class="code-attr-comment-block">;; B
</span><span class="code-attr-method">max</span>(1)(2) <span class="code-attr-comment-block">; 2 ;; AB
</span><span class="code-attr-method">max</span>(1 2)  <span class="code-attr-comment-block">; 2 ;; B
</span>
+= max { (first ...)        <span class="code-attr-comment-block">;; C
</span>  += max {a|a}              <span class="code-attr-comment-block">;; D
</span>  max first <span class="code-attr-method">max</span>(...)
}
<span class="code-attr-method">max</span>(1 2)     <span class="code-attr-comment-block">; 2 ;; CDB
</span><span class="code-attr-method">max</span>(1 2 3)   <span class="code-attr-comment-block">; 3 ;; CBB
</span><span class="code-attr-method">max</span>(1 2 3 4) <span class="code-attr-comment-block">; 4 ;; CCBBB
</span><span class="code-attr-method">max</span>(1) <span class="code-attr-comment-block">; {max 1 $0} ;; A
</span>
+= len {               0         } <span class="code-attr-comment-block">;; C
</span>+= len {first ...| + 1 len ...   } <span class="code-attr-comment-block">;; B
</span>+= len {ary      |     len ...ary} <span class="code-attr-comment-block">;; A
</span>len 0        <span class="code-attr-comment-block">; 0 ;; AC
</span>len 0 0 0    <span class="code-attr-comment-block">; 3 ;; BBBC
</span>len [0 0 0]  <span class="code-attr-comment-block">; 3 ;; ABBBC
</span>
+= len {[first ...rest] | len first rest} <span class="code-attr-comment-block">;; D
</span>+= len {first.rest      | len first rest} <span class="code-attr-comment-block">;; D'
</span>len [0 0 0]  <span class="code-attr-comment-block">; 3 ;; D'BBBC
</span>
...<span class="code-attr-string">"abc"</span>     <span class="code-attr-comment-block">; ('a' . 'b' . 'c') ; (! '\n' tail(..."abc"))
</span>len <span class="code-attr-string">"abc"</span>    <span class="code-attr-comment-block">; 3
</span>
+= <span class="code-attr-keyword">do</span> |v| v
+= <span class="code-attr-keyword">do</span> |v.w| &amp; v (<span class="code-attr-keyword">do</span> w)

+= f |a| <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"a"</span>
+= f |b| <span class="code-attr-keyword">echo</span> <span class="code-attr-string">"b"</span>
f <span class="code-attr-type">nil</span>   <span class="code-attr-comment-block">; "b"
</span>f <span class="code-attr-label">a</span>:<span class="code-attr-type">nil</span> <span class="code-attr-comment-block">; "a"
</span>f <span class="code-attr-label">b</span>:<span class="code-attr-type">nil</span> <span class="code-attr-comment-block">; "b"
</span>
<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 演算代入演算子の記法
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;  可変長演算子との整合性も視野に入れる
</span><span class="code-attr-comment-block">;;   `=+`の記法であれば加算処理を`=`に内包させることが可能
</span><span class="code-attr-comment-block">;;   `+=`であれば代入処理との区別が容易になる
</span><span class="code-attr-comment-block">;;
</span>= val 1
+= val 1 <span class="code-attr-comment-block">; 2（案１ 75%）
</span>=+ val 1 <span class="code-attr-comment-block">; 3（案２ 25%）
</span>+:val 1  <span class="code-attr-comment-block">; 4（束縛演算子`:`利用時）
</span>

<span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 記号の整理
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   ラムダ系の演算子と、ビット演算系演算子で`~`と`^`の記号を活用している
</span><span class="code-attr-comment-block">;;   両記号はどちらか一方のカテゴリでのみ一貫して利用されるべきである
</span><span class="code-attr-comment-block">;;      煩雑な記法になりやすい: `~[a] ~~ ^~a &amp;~ _0`
</span><span class="code-attr-comment-block">;;      対応案１: `~[a] ~~ ^~a ^&amp; _0`
</span><span class="code-attr-comment-block">;;      対応案２: `~[a] ~~ ^^a &amp;^ _0`
</span><span class="code-attr-comment-block">;;      対応案３: `^[a] ^^ ~~a &amp;~ _0`
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   ラムダ系演算子の統一
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;     `~`と`^`のどちらを使うべきか
</span><span class="code-attr-comment-block">;;        `~`の存在感を取るか、`^`の違和感を取るか
</span><span class="code-attr-comment-block">;;           `~(a b) + a b` vs  `^(a b) + a b`
</span><span class="code-attr-comment-block">;;           `~~ + _0 _1`   vs  `^ + _0 _1`
</span><span class="code-attr-comment-block">;;           `~print`       vs  `^print`
</span><span class="code-attr-comment-block">;;        `^`のほうが控えめな印象を受ける。メインの処理を引き立てる
</span><span class="code-attr-comment-block">;;        `^`はλ（ラムダ）記号と形が似ている
</span><span class="code-attr-comment-block">;;        `~`は溶け込みすぎる（適切な空白や`~~`記法の利用が求められる）
</span><span class="code-attr-comment-block">;;        `~`は環境によって表示方法が異なる。等幅フォントでは中央表示が多数派
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;   ビット演算系演算子の統一
</span><span class="code-attr-comment-block">;;  
</span><span class="code-attr-comment-block">;;     `~`と`^`のどちらを使うべきか
</span><span class="code-attr-comment-block">;;        `&amp;~` bitwise AND  vs  `&amp;^` bitwise AND
</span><span class="code-attr-comment-block">;;        `|~` bitwise OR   vs  `|^` bitwise OR
</span><span class="code-attr-comment-block">;;        `^~` XOR          vs  `^^` XOR
</span><span class="code-attr-comment-block">;;        `~~` bitwise NOT  vs  `~^` bitwise NOT
</span><span class="code-attr-comment-block">;;     `~`の印象: 「複雑」「混沌」「泥臭さ」「低レイヤー」「バイナリー」
</span><span class="code-attr-comment-block">;;     `^`の印象: 「特別」「異質」「未来」「クリーンルーム」
</span><span class="code-attr-comment-block">;;
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 用語
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; | 演算子　　 | オペレータに相当するもの
</span><span class="code-attr-comment-block">;; | 被演算子　 | オペランドに相当するもの
</span><span class="code-attr-comment-block">;; | 関数　　　 | 演算子と等価関係にあるもの。通常はラベル名で表現された関数のことを指す
</span><span class="code-attr-comment-block">;; | 演算子関数 | 演算子として定義された関数。通常は記号で表現された関数のことを指す
</span><span class="code-attr-comment-block">;; | メソッド　 | オブジェクトのメンバ関数
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; | 式　　　　 | 要素のまとまり
</span><span class="code-attr-comment-block">;; | 要素　　　 | 値や変数または要素式
</span><span class="code-attr-comment-block">;; | 要素式　　 | 式の要素となりうる式
</span><span class="code-attr-comment-block">;; | 複要素式　 | 複数の要素を持った式
</span><span class="code-attr-comment-block">;; | 値　　　　 | 単項式に相当するもの。数値や文字等のリテラルを含む
</span><span class="code-attr-comment-block">;; | 遅延評価式 | 遅延評価が可能な式。`#`装飾された式や仮引数
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; | 式渡し　　 | 遅延評価の仕組みによって式が渡ること／渡すこと
</span><span class="code-attr-comment-block">;; | 式の譲渡　 | 式渡しと同義
</span><span class="code-attr-comment-block">;; | 式の展開　 | 式の評価や実行と同義
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; | 字下げ　　 | インデントのこと。タブまたは空白２つ以上で表現される
</span><span class="code-attr-comment-block">;; | 段落　　　 | パラグラフのこと。同じ階層に並ぶ複数行のうちの各行のこと
</span><span class="code-attr-comment-block">;; | 階層　　　 | 字下げによって変化する式の位置や式の位置関係
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; | 組み込み型 | 標準型・基本型と同義。リスト型や文字列型も含む
</span><span class="code-attr-comment-block">;; | 基本構文　 | コア機能に組み込まれた基本的な記法。if文もといif関数はこれに含まれない
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; | コア機能　 | 言語仕様に相当するもの。本言語が持つ普遍的な機能
</span><span class="code-attr-comment-block">;; | 拡張機能　 | 処理系固有の機能として実装可能な仕様。コア機能の拡張または改変を伴う機能
</span><span class="code-attr-comment-block">;; | 影響度　　 | 仕様追加によって生じる既存仕様への影響の度合い
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; | javascript: | ECMAScriptによるコードを明示する際に利用
</span><span class="code-attr-comment-block">;; | clang:      | C言語によるコードを明示する際に利用。GCC拡張が有効なClangコンパイラを想定
</span><span class="code-attr-comment-block">;;
</span>

<span class="code-attr-comment-block">;;
</span>(= v (+ 1 2))  <span class="code-attr-comment-block">; 式
</span> =             <span class="code-attr-comment-block">; 関数・演算子
</span>   v           <span class="code-attr-comment-block">; 要素・被演算子
</span>      +        <span class="code-attr-comment-block">; 関数・演算子
</span>     (+ 1 2)   <span class="code-attr-comment-block">; 要素・要素式・式
</span>        1      <span class="code-attr-comment-block">; 要素・被演算子・値
</span>+ v 1          <span class="code-attr-comment-block">; 式
</span>+              <span class="code-attr-comment-block">; 関数・演算子
</span>  v            <span class="code-attr-comment-block">; 要素・被演算子・値・変数
</span>    1          <span class="code-attr-comment-block">; 要素・被演算子・値
</span>(<span class="code-attr-keyword">print</span> <span class="code-attr-string">"a"</span>)    <span class="code-attr-comment-block">; 式
</span> <span class="code-attr-keyword">print</span>         <span class="code-attr-comment-block">; 関数
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 実験
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; プロトタイプ ;;
</span><span class="code-attr-keyword">class</span> <span class="code-attr-object">String</span>
  <span class="code-attr-type">let</span> _lib __builtin__[<span class="code-attr-string">"string.h"</span>]
  <span class="code-attr-type">var</span> _s util.empty
<span class="code-attr-comment-block">;; 拡張 ;;
</span><span class="code-attr-keyword">class</span> <span class="code-attr-label">String</span>: <span class="code-attr-label">public</span>
  <span class="code-attr-keyword">func</span> replace (target replacement) <span class="code-attr-type">nil</span>
  <span class="code-attr-keyword">func</span> substr  (p n)
    _lib.slice _s p (+ p n)
    <span class="code-attr-comment-block">;_lib.substr p n
</span>    <span class="code-attr-comment-block">;_lib.copy (+ p _s) n _lib.new(n)
</span><span class="code-attr-keyword">class</span> <span class="code-attr-label">String</span>: <span class="code-attr-label">private</span>(mcException)
  <span class="code-attr-keyword">func</span> release () <span class="code-attr-type">nil</span>
<span class="code-attr-string">""</span>.release <span class="code-attr-comment-block">; &gt;&gt; mcException:(3:0) String.release &lt;&lt;
</span><span class="code-attr-comment-block">;; カテゴリー ;;
</span><span class="code-attr-keyword">class</span> <span class="code-attr-label">String</span>: <span class="code-attr-method">category</span>(regex)
  <span class="code-attr-keyword">func</span> replace (target replacement) <span class="code-attr-type">nil</span>
<span class="code-attr-string">"\t\n"</span>.<span class="code-attr-label">regex</span>:replace <span class="code-attr-string">"\\s"</span>, <span class="code-attr-string">" "</span>

[1 2 3].reduce |a b| + a b
<span class="code-attr-method">reduce</span>(|a b| + a b, [1 2 3])
<span class="code-attr-method">reduce</span>(|a b| + a b) [1 2 3]
<span class="code-attr-method">reduce</span>(&lt;a b&gt; + a b, [1 2 3])
<span class="code-attr-keyword">echo</span>, <span class="code-attr-method">reduce</span>(|a b| + a b) [1 2 3]
reduce&lt;|a b| + a b&gt; [1 2 3]
reduce {|a b| + a b} [1 2 3]
reduce [1 2 3] |a b| + a b
reduce=[1 2 3] |a b| + a b
reduce&lt;[1 2 3]&gt; |a b| + a b

<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 備考
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 配列リテラル`[1 2 3]`の採用を検討中
</span><span class="code-attr-comment-block">;;    リストリテラル`(1 2 3)`の廃止が可能になる
</span><span class="code-attr-comment-block">;; 辞書リテラル`{:key val}`を採用しない方針を検討中
</span><span class="code-attr-comment-block">;;    代替記法: `[:key val]`
</span><span class="code-attr-comment-block">;;    `{}`をラムダ式の糖衣構文として使いたい
</span><span class="code-attr-comment-block">;;    `{:`で始まる式を辞書リテラルと解釈するための仕様も検討
</span><span class="code-attr-comment-block">;; 二項演算優先の規約に例外的な仕様を設ける
</span><span class="code-attr-comment-block">;;    `+ 1 2 3`は`(+ 1 2 3)`として解釈される
</span><span class="code-attr-comment-block">;; 中置記法の実現するための拡張案を検討中
</span><span class="code-attr-comment-block">;;    C言語スタイルでの記述を可能にする
</span><span class="code-attr-comment-block">;;    記法の定義と制御をライブラリ側で行えるようにする
</span><span class="code-attr-comment-block">;;    インタプリタインタプリタの実現が必要
</span><span class="code-attr-comment-block">;;    言語仕様の肥大化に繋がる
</span><span class="code-attr-comment-block">;; fn関数はコア機能とせず、ユーザ定義を可能とする
</span><span class="code-attr-comment-block">;;    = fn ~~ (...) #(~~ ...)
</span><span class="code-attr-comment-block">;; return文を実現するための仕様が必要
</span><span class="code-attr-comment-block">;;    ユーザ定義を可能とする
</span>
<span class="code-attr-comment-block">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; サンプル（マークアップ言語）
</span><span class="code-attr-comment-block">;;
</span><span class="code-attr-comment-block">;; 本言語で解釈可能となる予定の構文案
</span><span class="code-attr-comment-block">;;
</span>
members
  -------------------------
    name   トム・ドリル
    email  tom<span class="code-attr-label">@gmail_com</span>
  -------------------------
    name   ボブ・グリーン
    email  bobby<span class="code-attr-label">@gmail_com</span>
  -------------------------
    name   メアリー・フロイト
    email  mary<span class="code-attr-label">@gmail_com</span>

<span class="code-attr-comment-block">;; {members: [
</span><span class="code-attr-comment-block">;;   {name: "tom",  email: "tom@gmail_com"  },
</span><span class="code-attr-comment-block">;;   {name: "bob",  email: "bobby@gmail_com"},
</span><span class="code-attr-comment-block">;;   {name: "mary", email: "mary@gmail_com" }, ]}
</span>
members
  
  name   トム・ドリル
  email  tom<span class="code-attr-label">@gmail_com</span>
  
  name   ボブ・グリーン
  email  bobby<span class="code-attr-label">@gmail_com</span>

--------------------
<span class="code-attr-label">name</span>:
  <span class="code-attr-object">Java</span>
<span class="code-attr-label">extensions</span>:
  [java jsp]
<span class="code-attr-label">keywords</span>:
  <span class="code-attr-keyword">import</span>, <span class="code-attr-keyword">extends</span>
--------------------
name <span class="code-attr-string">"C++"</span>
extensions [cpp cxx cp cc]
keywords
  <span class="code-attr-keyword">constexpr</span>
  mutable
  static_cast, const_cast
--------------------
<span class="code-attr-label">name</span>:       <span class="code-attr-object">Rust</span>
<span class="code-attr-label">extensions</span>: rs, rlib
<span class="code-attr-label">keywords</span>:   trait
            impl
            pub

<span class="code-attr-comment-block">;; [ { name:       "Java",
</span><span class="code-attr-comment-block">;;     extensions: ["java", "jsp"],
</span><span class="code-attr-comment-block">;;     keywords:   ["import", "extensions"] },
</span><span class="code-attr-comment-block">;;   { name:       "C++",
</span><span class="code-attr-comment-block">;;     extensions: ["cpp", "cxx"],
</span><span class="code-attr-comment-block">;;     keywords:   ["constexpr", "mutable", ["static_cast", "const_cast"]] }
</span><span class="code-attr-comment-block">;;   { name:       "Rust",
</span><span class="code-attr-comment-block">;;     extensions: ["rs", "rlib"],
</span><span class="code-attr-comment-block">;;     keywords:   ["trait", "impl", "pub"] }, ]
</span>
-
  item-1-1
  item-1-2
- item-2-1
  item-2-2
------------------
item-3-1
- item-3-1-1
- item-3-1-2
item-3-2 -
  item-3-2-1
  item-3-2-2
item-3-3
------------------
item-4-1
item-4-2
  item-4-2-1
  item-4-2-2

animal
  dog
    <span class="code-attr-object">Pug</span>
      - <span class="code-attr-object">Frank</span> the <span class="code-attr-object">Pug</span>
      - <span class="code-attr-keyword">APO</span>
    <span class="code-attr-object">Boston</span> terrier
      <span class="code-attr-object">Iggy</span>
      <span class="code-attr-object">Maron</span>
    <span class="code-attr-label">Bulldog</span>:
    <span class="code-attr-object">Golden</span> <span class="code-attr-label">Retriever</span>:
  cat
    <span class="code-attr-object">American</span> <span class="code-attr-label">Shorthair</span>:
    <span class="code-attr-object">Maine</span> <span class="code-attr-label">Coon</span>:
    <span class="code-attr-object">Siamese</span>
      - <span class="code-attr-object">Kitty</span>

<span class="code-attr-comment-block">;; {animal:
</span><span class="code-attr-comment-block">;;   {dog: ["Pug" : ["Frank the Pug", "APO"], "Boston terrier", ["Iggy", "Maron"]"Bulldog", "Golden Retriever"],
</span><span class="code-attr-comment-block">;;    cat: ["American Shorthair", "Maine Coon", "Siamese"]}}
</span></code></pre>					</div><!-- .entry-content -->
		<footer class="entry-meta">
					</footer><!-- .entry-meta -->
	</article><!-- #post -->
				
<div id="comments" class="comments-area">

	
	
	
</div><!-- #comments .comments-area -->			
		</div><!-- #content -->
	</div><!-- #primary -->


			<div id="secondary" class="widget-area" role="complementary">
						<aside id="text-3" class="widget widget_text"><h3 class="widget-title">スポンサーリンク</h3>			<div class="textwidget"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<style type="text/css">
@media (min-width:600px) { .adslot_side { width: 160px; }
@media (min-width:1000px) { .adslot_side { width: 300px; } }</style>
<ins class="adsbygoogle adslot_side" style="display:block" data-ad-client="ca-pub-5613714714878183" data-ad-slot="8227805750" data-ad-format="auto"></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({});</script></div>
		</aside><aside id="categories-2" class="widget widget_categories"><h3 class="widget-title">カテゴリー</h3>		<ul>
	<li class="cat-item cat-item-31"><a href="http://marycore.jp/prog/cpp/" >C++</a>
</li>
	<li class="cat-item cat-item-19"><a href="http://marycore.jp/prog/cocoa/" >Cocoa</a>
</li>
	<li class="cat-item cat-item-30"><a href="http://marycore.jp/prog/c-lang/" >C言語</a>
</li>
	<li class="cat-item cat-item-14"><a href="http://marycore.jp/affiliate/adsense/" >Googleアドセンス</a>
</li>
	<li class="cat-item cat-item-5"><a href="http://marycore.jp/prog/css/" >HTML/CSS</a>
</li>
	<li class="cat-item cat-item-57"><a href="http://marycore.jp/prog/js/" >JavaScript</a>
</li>
	<li class="cat-item cat-item-13"><a href="http://marycore.jp/prog/mamp/" >MAMP</a>
</li>
	<li class="cat-item cat-item-3"><a href="http://marycore.jp/news/" >News</a>
</li>
	<li class="cat-item cat-item-6"><a href="http://marycore.jp/prog/objective-c/" >Objective-C</a>
</li>
	<li class="cat-item cat-item-62"><a href="http://marycore.jp/prog/php/" >PHP</a>
</li>
	<li class="cat-item cat-item-53"><a href="http://marycore.jp/prog/ruby/" >Ruby</a>
</li>
	<li class="cat-item cat-item-23"><a href="http://marycore.jp/prog/swift/" >Swift</a>
</li>
	<li class="cat-item cat-item-9"><a href="http://marycore.jp/wordpress/" >WordPress</a>
</li>
	<li class="cat-item cat-item-18"><a href="http://marycore.jp/prog/xcode/" >Xcode &amp; Clang</a>
</li>
	<li class="cat-item cat-item-55"><a href="http://marycore.jp/code/" >コード</a>
</li>
	<li class="cat-item cat-item-20"><a href="http://marycore.jp/design/" >デザイン</a>
</li>
	<li class="cat-item cat-item-56"><a href="http://marycore.jp/net/" >ネット文化</a>
</li>
	<li class="cat-item cat-item-7"><a href="http://marycore.jp/mac/" >パソコン・Mac</a>
</li>
	<li class="cat-item cat-item-41"><a href="http://marycore.jp/programmer/" >プログラマ</a>
</li>
	<li class="cat-item cat-item-25"><a href="http://marycore.jp/coding/" >プログラミング／コーディング</a>
</li>
	<li class="cat-item cat-item-12"><a href="http://marycore.jp/smart/" >ライフハック</a>
</li>
	<li class="cat-item cat-item-50"><a href="http://marycore.jp/ascii-art/" >今週のAA</a>
</li>
	<li class="cat-item cat-item-17"><a href="http://marycore.jp/yurume/" >今週の一言</a>
</li>
	<li class="cat-item cat-item-64"><a href="http://marycore.jp/works/" >創作</a>
</li>
	<li class="cat-item cat-item-28"><a href="http://marycore.jp/irony/" >戯言</a>
</li>
	<li class="cat-item cat-item-49"><a href="http://marycore.jp/essay/" >日記・雑文</a>
</li>
	<li class="cat-item cat-item-45"><a href="http://marycore.jp/anime/" >漫画・アニメ</a>
</li>
	<li class="cat-item cat-item-27"><a href="http://marycore.jp/society/" >社会</a>
</li>
	<li class="cat-item cat-item-58"><a href="http://marycore.jp/think/" >考察</a>
</li>
	<li class="cat-item cat-item-21"><a href="http://marycore.jp/language/" >言語</a>
</li>
	<li class="cat-item cat-item-59"><a href="http://marycore.jp/music/" >音楽</a>
</li>
		</ul>
</aside><aside id="tag_cloud-2" class="widget widget_tag_cloud"><h3 class="widget-title">タグ</h3><div class="tagcloud"><a href="http://marycore.jp/tag/tag-it-culture/" class="tag-cloud-link tag-link-63 tag-link-position-1" style="font-size: 12.745762711864pt;" aria-label="IT教養 (29個の項目)">IT教養</a>
<a href="http://marycore.jp/tag/tag-programming-technique/" class="tag-cloud-link tag-link-36 tag-link-position-2" style="font-size: 17.847457627119pt;" aria-label="テクニック (80個の項目)">テクニック</a>
<a href="http://marycore.jp/tag/tag-programming-neta/" class="tag-cloud-link tag-link-29 tag-link-position-3" style="font-size: 16.661016949153pt;" aria-label="ネタ (63個の項目)">ネタ</a>
<a href="http://marycore.jp/tag/tag-marketing/" class="tag-cloud-link tag-link-51 tag-link-position-4" style="font-size: 8pt;" aria-label="マーケティング (11個の項目)">マーケティング</a>
<a href="http://marycore.jp/tag/tag-review/" class="tag-cloud-link tag-link-61 tag-link-position-5" style="font-size: 13.457627118644pt;" aria-label="レビュー (34個の項目)">レビュー</a>
<a href="http://marycore.jp/tag/tag-programming-deal/" class="tag-cloud-link tag-link-43 tag-link-position-6" style="font-size: 18.322033898305pt;" aria-label="問題対処 (89個の項目)">問題対処</a>
<a href="http://marycore.jp/tag/tag-programming-basic/" class="tag-cloud-link tag-link-38 tag-link-position-7" style="font-size: 20.576271186441pt;" aria-label="基礎知識 (137個の項目)">基礎知識</a>
<a href="http://marycore.jp/tag/tag-tech-essay/" class="tag-cloud-link tag-link-52 tag-link-position-8" style="font-size: 16.067796610169pt;" aria-label="技術エッセイ (56個の項目)">技術エッセイ</a>
<a href="http://marycore.jp/tag/tag-tech-column/" class="tag-cloud-link tag-link-34 tag-link-position-9" style="font-size: 16.779661016949pt;" aria-label="技術コラム (65個の項目)">技術コラム</a>
<a href="http://marycore.jp/tag/tag-society/" class="tag-cloud-link tag-link-48 tag-link-position-10" style="font-size: 14.28813559322pt;" aria-label="文化社会 (40個の項目)">文化社会</a>
<a href="http://marycore.jp/tag/tag-programming-methodology/" class="tag-cloud-link tag-link-39 tag-link-position-11" style="font-size: 17.491525423729pt;" aria-label="方法論 (75個の項目)">方法論</a>
<a href="http://marycore.jp/tag/tag-daily/" class="tag-cloud-link tag-link-47 tag-link-position-12" style="font-size: 13.813559322034pt;" aria-label="日常 (36個の項目)">日常</a>
<a href="http://marycore.jp/tag/tag-future/" class="tag-cloud-link tag-link-32 tag-link-position-13" style="font-size: 13.338983050847pt;" aria-label="未来考察 (33個の項目)">未来考察</a>
<a href="http://marycore.jp/tag/tag-programming-specification/" class="tag-cloud-link tag-link-42 tag-link-position-14" style="font-size: 19.627118644068pt;" aria-label="言語仕様 (115個の項目)">言語仕様</a>
<a href="http://marycore.jp/tag/tag-programming-detail/" class="tag-cloud-link tag-link-37 tag-link-position-15" style="font-size: 22pt;" aria-label="詳細解説 (182個の項目)">詳細解説</a>
<a href="http://marycore.jp/tag/tag-programming-wisdom/" class="tag-cloud-link tag-link-40 tag-link-position-16" style="font-size: 21.050847457627pt;" aria-label="豆知識 (151個の項目)">豆知識</a></div>
</aside><aside id="text-4" class="widget widget_text"><h3 class="widget-title">自作アプリ</h3>			<div class="textwidget"><h4 class="widget-sub-title">キーボード拡張アプリ</h4>
<div style="margin-left: 12px; margin-left: 0.8571428571rem;"><a href="http://marycore.jp/mctap/" target="_blank">McTap</a></div>
<h4 class="widget-sub-title">テキストエディタ</h4>
<div style="margin-left: 12px; margin-left: 0.8571428571rem; margin-bottom: 6px; margin-bottom: 0.4285714286rem;"><a href="http://marycore.jp/apps/" target="_blank">McEditor</a></div></div>
		</aside><aside id="text-7" class="widget widget_text"><h3 class="widget-title">寄付・支援</h3>			<div class="textwidget"><div style="margin:0 0 8px 0"><span>Amazon: </span><a class="inline-code-1" style="padding:4px 8px" href="http://goo.gl/R1E6WB" target="_blank">ほしい物リスト</a> <a class="inline-code-1" style="padding:4px 8px" href="http://goo.gl/8NYx4T" target="_blank">干し芋のリスト</a></div>
<div style="margin:0 0 12px 0"><span>Bitcoin: <code class="inline-code inline-code-2 our-bitcoin-address" style="padding:4px 8px">32dzgrtFGQ1jDphJcu9iFozujbQ2JKYDXs</code></span></div>
<div style="margin:0 0 8px 0"><a href="https://bitflyer.jp/?bf=q1by3zso" target="_blank"><img style="border-radius: unset; padding: 18px; background-color: #fff;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHUAAAB1AQAAAABYf5MRAAAAtElEQVR4AZzHoWEEQRTFMMNj7r/LB5c5JA38EROAUivgd75lGmQ9HJ2MKb7dhfR+pz2+VGha9wP+A+6vQh1W3/kmABvQ7/x0UqOx+yFwlOj9Rkk02P2Jk4i273zaGujQ3/3OaoZ7+CQIGtt3vuEGttX9ky0zhd/5pDKIenu2TVjf+aVsDfDpBdNMfucDMtfU3W85ghn77kdxOMC3N8JNf283asbDy1Aidj+guRL4zu9vKOAHABV0xOWkC7DVAAAAAElFTkSuQmCC"></a></div>
</div>
		</aside><aside id="mc_widget_214850853-2" class="widget widget_mc_widget_214850853"><h3 class="widget-title">よい物リスト</h3><div style="text-align:left;padding-bottom:20px;font-size:small"><div style="float:left;margin:0 15px 10px 0"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB01C0Q2WZC%2Fref%3Dnosim" target="_blank"><img src="https://images-fe.ssl-images-amazon.com/images/I/51qiQZJeSmL._SL160_.jpg" style="border:none" /></a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="line-height:120%"><div style="margin-bottom:10px;line-height:120%;overflow:hidden"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB01C0Q2WZC%2Fref%3Dnosim" target="_blank">Ted2 ぬいぐるみXL プレミアム Part3</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="margin-top:10px;overflow:hidden"><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3DTed2%2520%25E3%2581%25AC%25E3%2581%2584%25E3%2581%2590%25E3%2582%258B%25E3%2581%25BF%26__mk_ja_JP%3D%25E3%2582%25AB%25E3%2582%25BF%25E3%2582%25AB%25E3%2583%258A" target="_blank">Amazon</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371293&p_id=54&pc_id=54&pl_id=616&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fsearch.rakuten.co.jp%2Fsearch%2Fmall%2FTed2%2520%25E3%2581%25AC%25E3%2581%2584%25E3%2581%2590%25E3%2582%258B%25E3%2581%25BF%2F-%2Ff.1-p.1-s.1-sf.0-st.A-v.2%3Fx%3D0" target="_blank">楽天市場</a><img src="//i.moshimo.com/af/i/impression?a_id=371293&p_id=54&pc_id=54&pl_id=616" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//ck.jp.ap.valuecommerce.com/servlet/referral?sid=3058386&pid=881893837&vc_url=http%3A%2F%2Fsearch.shopping.yahoo.co.jp%2Fsearch%3Fp%3DTed2%2520%25E3%2581%25AC%25E3%2581%2584%25E3%2581%2590%25E3%2582%258B%25E3%2581%25BF" target="_blank">Yahooショッピング<img src="//ad.jp.ap.valuecommerce.com/servlet/gifbanner?sid=3058386&pid=881893837" height="1" width="1" border="0"></a></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=623330&p_id=932&pc_id=1188&pl_id=12456&s_v=b5Rz2P0601xu&url=http%3A%2F%2F7net.omni7.jp%2Fsearch%2F%3Fkeyword%3DTed2%2520%25E3%2581%25AC%25E3%2581%2584%25E3%2581%2590%25E3%2582%258B%25E3%2581%25BF%26searchKeywordFlg%3D1" target="_blank"><img src="//i.moshimo.com/af/i/impression?a_id=623330&p_id=932&pc_id=1188&pl_id=12456" width="1" height="1" style="border:none">7net</a></span><div style="margin-top:15px">早くこれになりたい</div></div></div><div style="clear:both"></div></div><div style="text-align:left;padding-bottom:20px;font-size:small"><div style="float:left;margin:0 15px 10px 0"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB01F8M9CCQ%2Fref%3Dnosim" target="_blank"><img src="https://images-fe.ssl-images-amazon.com/images/I/416xVIJvJLL._SL160_.jpg" style="border:none" /></a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="line-height:120%"><div style="margin-bottom:10px;line-height:120%;overflow:hidden"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB01F8M9CCQ%2Fref%3Dnosim" target="_blank">東プレ キーボード REALFORCE91UG-S 日本語カナなし 91keyテンキーレスUSB 静電容量無接点 昇華印刷 静音モデル ALL30g荷重 ブラック/グレー NG31BS</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="margin-top:10px;overflow:hidden"><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3DREALFORCE%2520ALL30g%26__mk_ja_JP%3D%25E3%2582%25AB%25E3%2582%25BF%25E3%2582%25AB%25E3%2583%258A" target="_blank">Amazon</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371293&p_id=54&pc_id=54&pl_id=616&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fsearch.rakuten.co.jp%2Fsearch%2Fmall%2FREALFORCE%2520ALL30g%2F-%2Ff.1-p.1-s.1-sf.0-st.A-v.2%3Fx%3D0" target="_blank">楽天市場</a><img src="//i.moshimo.com/af/i/impression?a_id=371293&p_id=54&pc_id=54&pl_id=616" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//ck.jp.ap.valuecommerce.com/servlet/referral?sid=3058386&pid=881893837&vc_url=http%3A%2F%2Fsearch.shopping.yahoo.co.jp%2Fsearch%3Fp%3DREALFORCE%2520ALL30g" target="_blank">Yahooショッピング<img src="//ad.jp.ap.valuecommerce.com/servlet/gifbanner?sid=3058386&pid=881893837" height="1" width="1" border="0"></a></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=623330&p_id=932&pc_id=1188&pl_id=12456&s_v=b5Rz2P0601xu&url=http%3A%2F%2F7net.omni7.jp%2Fsearch%2F%3Fkeyword%3DREALFORCE%2520ALL30g%26searchKeywordFlg%3D1" target="_blank"><img src="//i.moshimo.com/af/i/impression?a_id=623330&p_id=932&pc_id=1188&pl_id=12456" width="1" height="1" style="border:none">7net</a></span><div style="margin-top:15px">ガチ勢が使うキーボード</div></div></div><div style="clear:both"></div></div><div style="text-align:left;padding-bottom:20px;font-size:small"><div style="float:left;margin:0 15px 10px 0"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB01MTEAV6O%2Fref%3Dnosim" target="_blank"><img src="https://images-fe.ssl-images-amazon.com/images/I/51gOrE1xIkL._SL160_.jpg" style="border:none" /></a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="line-height:120%"><div style="margin-bottom:10px;line-height:120%;overflow:hidden"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB01MTEAV6O%2Fref%3Dnosim" target="_blank">【Amazon.co.jp限定】はごろも ポポロスパ7分 5kg 1.6mm</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="margin-top:10px;overflow:hidden"><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3D%25E3%2583%259D%25E3%2583%259D%25E3%2583%25AD%25E3%2582%25B9%25E3%2583%2591%26__mk_ja_JP%3D%25E3%2582%25AB%25E3%2582%25BF%25E3%2582%25AB%25E3%2583%258A" target="_blank">Amazon</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371293&p_id=54&pc_id=54&pl_id=616&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fsearch.rakuten.co.jp%2Fsearch%2Fmall%2F%25E3%2583%259D%25E3%2583%259D%25E3%2583%25AD%25E3%2582%25B9%25E3%2583%2591%2F-%2Ff.1-p.1-s.1-sf.0-st.A-v.2%3Fx%3D0" target="_blank">楽天市場</a><img src="//i.moshimo.com/af/i/impression?a_id=371293&p_id=54&pc_id=54&pl_id=616" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//ck.jp.ap.valuecommerce.com/servlet/referral?sid=3058386&pid=881893837&vc_url=http%3A%2F%2Fsearch.shopping.yahoo.co.jp%2Fsearch%3Fp%3D%25E3%2583%259D%25E3%2583%259D%25E3%2583%25AD%25E3%2582%25B9%25E3%2583%2591" target="_blank">Yahooショッピング<img src="//ad.jp.ap.valuecommerce.com/servlet/gifbanner?sid=3058386&pid=881893837" height="1" width="1" border="0"></a></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=623330&p_id=932&pc_id=1188&pl_id=12456&s_v=b5Rz2P0601xu&url=http%3A%2F%2F7net.omni7.jp%2Fsearch%2F%3Fkeyword%3D%25E3%2583%259D%25E3%2583%259D%25E3%2583%25AD%25E3%2582%25B9%25E3%2583%2591%26searchKeywordFlg%3D1" target="_blank"><img src="//i.moshimo.com/af/i/impression?a_id=623330&p_id=932&pc_id=1188&pl_id=12456" width="1" height="1" style="border:none">7net</a></span><div style="margin-top:15px">筋トレ用</div></div></div><div style="clear:both"></div></div><div style="text-align:left;padding-bottom:20px;font-size:small"><div style="float:left;margin:0 15px 10px 0"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB00DCKF4OC%2Fref%3Dnosim" target="_blank"><img src="https://images-fe.ssl-images-amazon.com/images/I/61fkY7esaZL._SL160_.jpg" style="border:none" /></a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="line-height:120%"><div style="margin-bottom:10px;line-height:120%;overflow:hidden"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB00DCKF4OC%2Fref%3Dnosim" target="_blank">キユーピー あえるパスタソース6種 [カルボナーラ1袋(2食入)、たらこ1袋(2食入)、ミートソース フォン・ド・ヴォー1袋(2食入)、バジル1袋(2食入)、ツナマヨ1袋(2食入)、きのこの醤油バター1袋(2食入り)]</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="margin-top:10px;overflow:hidden"><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3D%25E3%2583%2591%25E3%2582%25B9%25E3%2582%25BF%25E3%2582%25BD%25E3%2583%25BC%25E3%2582%25B9%26__mk_ja_JP%3D%25E3%2582%25AB%25E3%2582%25BF%25E3%2582%25AB%25E3%2583%258A" target="_blank">Amazon</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371293&p_id=54&pc_id=54&pl_id=616&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fsearch.rakuten.co.jp%2Fsearch%2Fmall%2F%25E3%2583%2591%25E3%2582%25B9%25E3%2582%25BF%25E3%2582%25BD%25E3%2583%25BC%25E3%2582%25B9%2F-%2Ff.1-p.1-s.1-sf.0-st.A-v.2%3Fx%3D0" target="_blank">楽天市場</a><img src="//i.moshimo.com/af/i/impression?a_id=371293&p_id=54&pc_id=54&pl_id=616" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//ck.jp.ap.valuecommerce.com/servlet/referral?sid=3058386&pid=881893837&vc_url=http%3A%2F%2Fsearch.shopping.yahoo.co.jp%2Fsearch%3Fp%3D%25E3%2583%2591%25E3%2582%25B9%25E3%2582%25BF%25E3%2582%25BD%25E3%2583%25BC%25E3%2582%25B9" target="_blank">Yahooショッピング<img src="//ad.jp.ap.valuecommerce.com/servlet/gifbanner?sid=3058386&pid=881893837" height="1" width="1" border="0"></a></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=623330&p_id=932&pc_id=1188&pl_id=12456&s_v=b5Rz2P0601xu&url=http%3A%2F%2F7net.omni7.jp%2Fsearch%2F%3Fkeyword%3D%25E3%2583%2591%25E3%2582%25B9%25E3%2582%25BF%25E3%2582%25BD%25E3%2583%25BC%25E3%2582%25B9%26searchKeywordFlg%3D1" target="_blank"><img src="//i.moshimo.com/af/i/impression?a_id=623330&p_id=932&pc_id=1188&pl_id=12456" width="1" height="1" style="border:none">7net</a></span><div style="margin-top:15px">独身プログラマの強い味方</div></div></div><div style="clear:both"></div></div><div style="text-align:left;padding-bottom:20px;font-size:small"><div style="float:left;margin:0 15px 10px 0"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB074C9NPDL%2Fref%3Dnosim" target="_blank"><img src="https://images-fe.ssl-images-amazon.com/images/I/31ojuKtDw0L._SL160_.jpg" style="border:none" /></a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="line-height:120%"><div style="margin-bottom:10px;line-height:120%;overflow:hidden"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2FB074C9NPDL%2Fref%3Dnosim" target="_blank">アルタ 抱き枕 もっちり 床ごこち 添い寝  クマ ごろう AR0628121</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></div><div style="margin-top:10px;overflow:hidden"><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371288&p_id=170&pc_id=185&pl_id=4062&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3D%25E3%2582%25AF%25E3%2583%259E%2520%25E6%258A%25B1%25E3%2581%258D%25E6%259E%2595%26__mk_ja_JP%3D%25E3%2582%25AB%25E3%2582%25BF%25E3%2582%25AB%25E3%2583%258A" target="_blank">Amazon</a><img src="//i.moshimo.com/af/i/impression?a_id=371288&p_id=170&pc_id=185&pl_id=4062" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=371293&p_id=54&pc_id=54&pl_id=616&s_v=b5Rz2P0601xu&url=http%3A%2F%2Fsearch.rakuten.co.jp%2Fsearch%2Fmall%2F%25E3%2582%25AF%25E3%2583%259E%2520%25E6%258A%25B1%25E3%2581%258D%25E6%259E%2595%2F-%2Ff.1-p.1-s.1-sf.0-st.A-v.2%3Fx%3D0" target="_blank">楽天市場</a><img src="//i.moshimo.com/af/i/impression?a_id=371293&p_id=54&pc_id=54&pl_id=616" width="1" height="1" style="border:none"></span><span style="margin-right:5px"><a href="//ck.jp.ap.valuecommerce.com/servlet/referral?sid=3058386&pid=881893837&vc_url=http%3A%2F%2Fsearch.shopping.yahoo.co.jp%2Fsearch%3Fp%3D%25E3%2582%25AF%25E3%2583%259E%2520%25E6%258A%25B1%25E3%2581%258D%25E6%259E%2595" target="_blank">Yahooショッピング<img src="//ad.jp.ap.valuecommerce.com/servlet/gifbanner?sid=3058386&pid=881893837" height="1" width="1" border="0"></a></span><span style="margin-right:5px"><a href="//af.moshimo.com/af/c/click?a_id=623330&p_id=932&pc_id=1188&pl_id=12456&s_v=b5Rz2P0601xu&url=http%3A%2F%2F7net.omni7.jp%2Fsearch%2F%3Fkeyword%3D%25E3%2582%25AF%25E3%2583%259E%2520%25E6%258A%25B1%25E3%2581%258D%25E6%259E%2595%26searchKeywordFlg%3D1" target="_blank"><img src="//i.moshimo.com/af/i/impression?a_id=623330&p_id=932&pc_id=1188&pl_id=12456" width="1" height="1" style="border:none">7net</a></span><div style="margin-top:15px">休日の旦那</div></div></div><div style="clear:both"></div></div></aside>					</div><!-- #secondary -->
	</div><footer id="colophon" role="contentinfo"><div class="site-info">Copyright (C) 2012-2018 <a href="http://marycore.jp/" title="Think Difficult. (；･`д･´)">MaryCore</a>. All rights reserved.</div></footer></div>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-37354401-1','auto');ga('send','pageview');</script><script>
(function(){var c=document.getElementById("site-navigation");if(c){var a=c.getElementsByTagName("button")[0];if(a){var b=c.getElementsByTagName("ul")[0];if(!b||!b.childNodes.length)return a.style.display="none";a.onclick=function(){-1===b.className.indexOf("nav-menu")&&(b.className="nav-menu");-1!==a.className.indexOf("toggled-on")?(a.className=a.className.replace(" toggled-on",""),b.className=b.className.replace(" toggled-on","")):(a.className+=" toggled-on",b.className+=" toggled-on")}}}})();</script>
</body></html>